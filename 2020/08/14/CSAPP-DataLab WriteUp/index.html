<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"srpopty.github.io","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="CS:APP DataLab WriteUp.">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP-DataLab WriteUp">
<meta property="og:url" content="https://srpopty.github.io/2020/08/14/CSAPP-DataLab%20WriteUp/index.html">
<meta property="og:site_name" content="Shadow Gallery">
<meta property="og:description" content="CS:APP DataLab WriteUp.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-14T09:02:30.000Z">
<meta property="article:modified_time" content="2020-08-16T09:56:16.268Z">
<meta property="article:author" content="Srpopty">
<meta property="article:tag" content="WriteUp">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://srpopty.github.io/2020/08/14/CSAPP-DataLab%20WriteUp/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>CSAPP-DataLab WriteUp | Shadow Gallery</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Shadow Gallery" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Shadow Gallery</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Live in the shadow</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://srpopty.github.io/2020/08/14/CSAPP-DataLab%20WriteUp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Srpopty">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shadow Gallery">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSAPP-DataLab WriteUp
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-14 17:02:30" itemprop="dateCreated datePublished" datetime="2020-08-14T17:02:30+08:00">2020-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-16 17:56:16" itemprop="dateModified" datetime="2020-08-16T17:56:16+08:00">2020-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          
            <div class="post-description">CS:APP DataLab WriteUp.</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>在这个Lab中主要需要完成bits.c文件中的部分函数以实现函数功能，代码必须顺序执行，即不能使用if条件分支或者While循环这一类，此外对于函数的实现必须使用指定的位操作符，例如与或非(&amp;,|,)等，具体每个函数的限制也不一样。</p>
<p>在完成bits.c后使用dlc进行检查，例如<code>./dlc bits.c</code>，检查函数的实现是否遵循指定的规则，检查通过后使用btest开始测试函数的输入与输出，btest需要先编译再运行，例如<code>make clean &amp;&amp; make btest &amp;&amp; ./btest</code>。btest将会对每一个函数给定指定的输入，检查输出是否正确，每一个函数都有一个等级与分值，等级越高难度和分数也越高。</p>
<p>具体规则如下：</p>
<ul>
<li>函数中禁止使用if, do, while, for, switch之类的控制语句。</li>
<li>文件中禁止定义任何宏，禁止定义任何额外的函数。</li>
<li>禁止调用函数。</li>
<li>在int类型的题目中禁止定义除int类型以外的变量。在float类型的题目中禁止定义除int和unsigned类型以外的变量，也禁止使用flaot类型与浮点数操作符。</li>
<li>函数中定义int类型的常量范围在<code>0x00 &lt;= int &lt;= 0xff</code>，不能大于0xff。</li>
<li>不能使用全局变量，只能使用函数参数与局部变量。</li>
<li>操作符限制为一元操作符<code>! ~</code>和位操作符<code>&amp; ^ | + &lt;&lt; &gt;&gt;</code>，部分函数中可能仅允许使用一部分操作符。禁止使用二元与三元操作符，例如<code>|| &amp;&amp; ? -</code></li>
<li>在每个函数中会限制出现的操作符的数量，一条语句可以使用多个数量限制内的操作符。</li>
</ul>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><p>在C语言中，32位的操作系统上一个int类型的变量占32个比特位，即4个字节。从右向左，代表从低位到高位，其中最高位(最左边)的比特位表示该数字的符号，1表示该数字为负数，0表示该数字为正数，后续的31个比特位中存放才是该数字的二进制数据，能存储的数字范围为$-2^31&lt;=int&lt;=2^31$，即$-2147483648&lt;=int&lt;=2147483648$。与int相比，无符号数unsigned int不需要符号位，所以可以多存储一位数据，其范围为$-4294967296&lt;=unsigned&lt;=4294967296$。</p>
<p>上述的数值二进制表示方法称为原码，除了原码，计算机中还有反码与补码两种表示方法。正数的反码与补码和原码相同，而负数的反码为：符号位不变，其余位取反，负数的补码为：负数的反码加1。反码的意义在于进行减法的时候计算机计算比较方便，而补码的意义在于解决+0与-0的问题：由于int的最高位是符号位，当数据位都为0时，数字0就有了两种表示方法，符号位是0(即0x0)代表+0和符号位是1(即0x80000000)代表-0。此外补码还可以得到该数的相反数。</p>
<p>位操作符是C语言中最基本的操作符，将两个数字按比特位进行操作，使用位操作符的计算速度是最快的。C语言中主要有以下位操作符，其中移位运算符的优先级比算术运算符的优先级更低。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>位且</td>
<td>两个数按位进行且运算，两个相比较的比特位中只要有一个0，那么该位的结果就是0</td>
</tr>
<tr>
<td>|位或</td>
<td>两个数按位进行或运算，两个相比较的比特位中只要有一个1，那么该位的结果就是1</td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
<td>两个数按位进行异或运算，两个相比较的比特位如果不一样那么该位的结果为1，否则为0</td>
</tr>
<tr>
<td>~</td>
<td>取反</td>
<td>将该数按位进行取反，0变成1，1变成0</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>算术左移</td>
<td>将该数每一位左移指定位数，右边补0，左移几位就是将原数乘以2的几次方</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>算术右移</td>
<td>将该数每一位右移指定位数，左边补符号位，若符号位是1则补1，负责补0，仅针对正数而言右移几位就是将原数除以2的几次方</td>
</tr>
</tbody></table>
<p>浮点数的表示方法与整数完全不同。IEEE规定单精度浮点数float用1位表示符号，8位表示指数，剩下的23位表示尾数，双精度浮点数用1位表示符号，11位表示指数，剩下的52位表示尾数。在计算机中任何浮点数都可以表示为<br>$$(-1)^s*(1.m)^*2^(E-127)$$</p>
<p>其中s代表符号位，m代表尾数，E代表阶码。</p>
<ul>
<li>如果阶码E=255并且m非零，则该数不是一个属，代表NaN(Not a number)。</li>
<li>如果阶码E=255并且m为0，那么该数根据符号位代表正负无穷。</li>
<li>如果阶码E=0并且m为0，那么该数根据符号位代表正负零。</li>
</ul>
<h1 id="Bit-Manipulations"><a href="#Bit-Manipulations" class="headerlink" title="Bit Manipulations"></a>Bit Manipulations</h1><h2 id="bitAnd"><a href="#bitAnd" class="headerlink" title="bitAnd"></a>bitAnd</h2><p>使用<code>~</code>与<code>|</code>实现位与运算符，例如<code>bitAnd(6, 5) = 6 &amp; 5 =4</code>，最大操作符数量为8，等级为1。</p>
<p>根据对合律与对偶律可得<code>a&amp;b = ~(~(a&amp;b))=~(~a|~b)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitAnd - x&amp;y using only ~ and |</span></span><br><span class="line"><span class="comment"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ |</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~( ~x | ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h2><p>获取一个整数x中的第n个字节，n的范围在<code>0 &lt;= n &lt;= 3</code>，例如<code>getByte(0x12345678,1) = 0x56</code>。允许的操作符为<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>，最大操作符数量为6，等级为2。</p>
<p>可以利用位且操作符的性质，让其余位清0即可获取指定位的数值，例如<code>0x1234 &amp; 0x00ff= 0x34</code>，<code>0x1234 &amp; 0xff00 = 0x12</code>。可以让0xff左移n*8位就可以获取第n个字节，其余位都被清0了，之后再将获取到的字节右移回n*8位就可以了。由于无法使用乘号<code>*</code>，但是乘数刚好是2的倍数，因此可以使用左移代替乘法<code>n * 8 = n &lt;&lt; 3</code>。原理如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; x&#x3D;0x12345678, n&#x3D;1</span><br><span class="line">0x12345678</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将0xff左移8*1位</span><br><span class="line">0x000000ff</span><br><span class="line">0x0000ff00</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 与原数进行位且运算</span><br><span class="line">0x00005600</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 再右移8*1位</span><br><span class="line">0x00000056</span><br></pre></td></tr></table></figure>

<p>注意C语言里使用的是算术右移，即有符号数右移时符号位保持不变，符号位向右移动后正数在符号位补0，负数补1，因此若右移了一个负数，则被右移的位数上将都为1，因此在最后还需要使用位且运算符只保留前1个字节。如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; x&#x3D;0x80000000, n&#x3D;3</span><br><span class="line">0x80000000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将0xff左移8*3位</span><br><span class="line">0x000000ff</span><br><span class="line">0xff000000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 进行位且运算</span><br><span class="line">0x80000000</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 再右移8*3位</span><br><span class="line">0xffffff80 &#x2F;&#x2F; 由于是负数，符号位补1，因此右移了很多1</span><br><span class="line">0x000000ff &#x2F;&#x2F; 进行位且运算将其余字节清0</span><br><span class="line">0x00000080</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * getByte - Extract byte n from word x</span><br><span class="line"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span><br><span class="line"> *   Examples: getByte(0x12345678,1) &#x3D; 0x56</span><br><span class="line"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line"> *   Max ops: 6</span><br><span class="line"> *   Rating: 2</span><br><span class="line"> *&#x2F;</span><br><span class="line">int getByte(int x, int n) &#123;</span><br><span class="line">    return ((x &amp; (0xff&lt;&lt;(n&lt;&lt;3))) &gt;&gt; (n&lt;&lt;3)) &amp; 0xff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="logicalShift"><a href="#logicalShift" class="headerlink" title="logicalShift"></a>logicalShift</h2><p>将整数x右移n位，n的范围在<code>0 &lt;= n &lt;= 31</code>，例如<code>logicalShift(0x87654321,4) = 0x08765432</code>。允许的操作符为<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>，最大操作符数量为20，等级为3。</p>
<p>在C语言里的位右移是算术右移，若右移的数是有符号数，则符号位正数补0，负数补1，例如0x8000右移8位得到0xff80，而逻辑右移是不管符号位的，全部补0。因此在执行算术右移以后，需要将被移动的位数全部清0。将0x1左移31位以后就变成了0x80000000(0b100000…)，这时再使用算术右移n-1位就可以将前n-1位指定为1，再取反就可以将前n-1位清0。原理如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0x00000001</span><br><span class="line">&#x2F;&#x2F; 左移31位</span><br><span class="line">0x80000000</span><br><span class="line">&#x2F;&#x2F; 再右移n-1位，假设n&#x3D;5</span><br><span class="line">0xf8000000</span><br><span class="line">&#x2F;&#x2F; 变成0b1111 1000 0000... 再取反</span><br><span class="line">0x07ffffff</span><br><span class="line">&#x2F;&#x2F; 变成0b0000 0111 1111...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 假设原数为0x80000000，即0b1000 0000 0000...</span><br><span class="line">0x80000000</span><br><span class="line">&#x2F;&#x2F; 将原数算术右移n&#x3D;5位，变成0b1111 1100 0000...</span><br><span class="line">0xfc000000</span><br><span class="line">&#x2F;&#x2F; 再与前面得到的0x07ffffff位且运算，前5位被清零</span><br><span class="line">0x04000000</span><br><span class="line">&#x2F;&#x2F; 即可得到逻辑位移的结果</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; n) &amp; ~(((one &lt;&lt; <span class="number">31</span>) &gt;&gt; n) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bitCount"><a href="#bitCount" class="headerlink" title="bitCount"></a>bitCount</h2><p>获得整数v中二进制1的个数，例如<code>bitCount(5) = 2, bitCount(7) = 3</code>。允许的操作符为<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>，最大操作符数量为40，等级为4。<br>这个题非常难，其原理就是将32位进行分组，每2位为一组，分别计算出每组1的数量，关于计算每组1的数量可以使用010101…这样的掩码，先用位且运算计算每组低位1的数量，再将原数右移1位计算每组高位1的数量，相加即可得到每组1的数量，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设原数为0x7a2d，其二进制如下</span><br><span class="line">0b01 11 10 10 00 10 11 01</span><br><span class="line">&#x2F;&#x2F; 掩码如下</span><br><span class="line">0b01 01 01 01 01 01 01 01</span><br><span class="line">&#x2F;&#x2F; 进行且或运算得到每组低位1的数量得到结果a</span><br><span class="line">0b01 01 00 00 00 00 01 01</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将原数右移1位，这样高位就到了低位</span><br><span class="line">0b00 11 11 01 00 01 01 10</span><br><span class="line">&#x2F;&#x2F; 与掩码进行且或运算计算每组低位1的数量得到结果b</span><br><span class="line">0b00 01 01 01 00 01 01 00</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将结果a与结果b相加即可得到每组1的数量</span><br><span class="line">0b01 01 00 00 00 00 01 01 +</span><br><span class="line">0b00 01 01 01 00 01 01 00 &#x3D;</span><br><span class="line">0b01 10 01 01 00 01 10 01</span><br></pre></td></tr></table></figure>

<p>之后再每2组相加得到每4组1的数量，相加可以使用掩码00110011…，分别得到低两位1的数量与高两位1的数量，再相加，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 刚才计算每两位为一组的1的数量</span><br><span class="line">0b0110 0101 0001 1001</span><br><span class="line">&#x2F;&#x2F; 掩码如下</span><br><span class="line">0b0011 0011 0011 0011</span><br><span class="line">&#x2F;&#x2F; 进行且或运算得到每组低两位的1的数量得到结果a</span><br><span class="line">0b0010 0001 0001 0001</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将原数右移2位，这样高两位就到了低两位</span><br><span class="line">0b0001 1001 0100 0110</span><br><span class="line">&#x2F;&#x2F; 与掩码进行且或运算计算每4位一组的低两位1的数量得到结果b</span><br><span class="line">0b0001 0001 0000 0001</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将结果a与结果b相加即可得到每组1的数量</span><br><span class="line">0b0010 0001 0001 0001 +</span><br><span class="line">0b0001 0001 0000 0001 &#x3D;</span><br><span class="line">0b0011 0010 0001 0010</span><br></pre></td></tr></table></figure>

<p>之后再重复这样的操作，再分为8位一组计算，掩码为0b0000111100001111…，再分为16位一组计算，掩码为0b0000000011111111…，最后相加即可得到32位里1的数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitCount - returns count of number of 1&#x27;s in word</span></span><br><span class="line"><span class="comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 40</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0x55</span>|(<span class="number">0x55</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> mask_2bit = tmp|(tmp&lt;&lt;<span class="number">16</span>);  <span class="comment">// 0b01010101...</span></span><br><span class="line">    tmp = <span class="number">0x33</span>|(<span class="number">0x33</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> mask_4bit = tmp|(tmp&lt;&lt;<span class="number">16</span>); <span class="comment">// 0b001100110011...</span></span><br><span class="line">    tmp = <span class="number">0x0f</span>|(<span class="number">0x0f</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> mask_8bit = tmp|(tmp&lt;&lt;<span class="number">16</span>);  <span class="comment">// 0b0000111100001111...</span></span><br><span class="line">    <span class="keyword">int</span> mask_16bit = <span class="number">0xff</span>|(<span class="number">0xff</span>&lt;&lt;<span class="number">16</span>);  <span class="comment">// 0b0000000011111111...</span></span><br><span class="line">    <span class="keyword">int</span> mask_32bit = <span class="number">0xff</span>|(<span class="number">0xff</span>&lt;&lt;<span class="number">8</span>);  <span class="comment">// 00000000000000001111111111...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = (v&amp;mask_2bit) + ((v&gt;&gt;<span class="number">1</span>)&amp;mask_2bit);  <span class="comment">// Each group with 2 bits.</span></span><br><span class="line">    c = (c&amp;mask_4bit) + ((c&gt;&gt;<span class="number">2</span>)&amp;mask_4bit);  <span class="comment">// Each group with 4 bits.</span></span><br><span class="line">    c = (c&amp;mask_8bit) + ((c&gt;&gt;<span class="number">4</span>)&amp;mask_8bit);  <span class="comment">// Each group with 8 bits.</span></span><br><span class="line">    c = (c&amp;mask_16bit) + ((c&gt;&gt;<span class="number">8</span>)&amp;mask_16bit);  <span class="comment">// Each group with 16 bits.</span></span><br><span class="line">    <span class="keyword">return</span> (c&amp;mask_32bit) + ((c&gt;&gt;<span class="number">16</span>)&amp;mask_32bit);  <span class="comment">// Only one group with 32 bits.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h2><p>不使用非运算符计算出<code>!x</code>，例如<code>bang(3) = 0, bang(0) = 1</code>。允许的操作符为<code>~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>，最大操作符数量为12，等级为4。</p>
<p>非运算符的作用非常简单，就是0返回1，非0返回0，所以重点就需要判断输入的数是否是0。关于判断是否为0有两种方法，一种是将二进制位所有高位的1全部右移到低位，直到只剩下1个二进制位为止，直接判断该二进制是否为0即可，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设原数x为0x18</span><br><span class="line">0b00011000</span><br><span class="line">&#x2F;&#x2F; 右移一半(4位)</span><br><span class="line">0b00000001</span><br><span class="line">&#x2F;&#x2F; 与原数做位或运算得到结果a</span><br><span class="line">0b00011001</span><br><span class="line">&#x2F;&#x2F; 再将a右移一半(2位)</span><br><span class="line">0b00000110</span><br><span class="line">&#x2F;&#x2F; 与a做位或运算得到结果b</span><br><span class="line">0b00011111</span><br><span class="line">&#x2F;&#x2F; 再将b右移一半(1位)</span><br><span class="line">0b00001111</span><br><span class="line">&#x2F;&#x2F; 与b做位或运算得到结果c</span><br><span class="line">0b00011111</span><br><span class="line">&#x2F;&#x2F; 取c的最后一位就可以判断原数x是否含有1</span><br></pre></td></tr></table></figure>

<p>另一种方法就是利用0的补码的特殊性质。计算补码使用的公式为<code>~x+1</code>，而除了0和0x80000000以外其他数使用该公式都会得到其相反数，最高位符号位总是不同。而0和0x80000000这两个数计算出来的则是他们本身：如果要计算0的补码，就需要计算<code>~0+1</code>，而~0的值是0xffffffff，如果再加1则会溢出，变成0x0，所以0的补码还是0，最高位也是0，而0x80000000的补码最高位还是1，因此就可以通过比较<code>x</code>与<code>~x+1</code>的符号位是否是1来判断<code>x</code>是否是0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bang - Compute !x without using !</span></span><br><span class="line"><span class="comment"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((x &gt;&gt; <span class="number">31</span>) | ((~x + <span class="number">0x1</span>) &gt;&gt; <span class="number">31</span>)) + <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Two’s-Complement-Arithmetic"><a href="#Two’s-Complement-Arithmetic" class="headerlink" title="Two’s Complement Arithmetic"></a>Two’s Complement Arithmetic</h1><h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><p>返回最小的补码整数。限制的操作符为<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>。最大操作符数目为4。等级为1。</p>
<p>最小的补码整数为0x80000000。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fitsBits"><a href="#fitsBits" class="headerlink" title="fitsBits"></a>fitsBits</h2><p>判断一个数x是否可以用n位补码表示，其中<code>1 &lt;= n &lt;= 32</code>。例如<code>fitsBits(5,3) = 0, fitsBits(-4,3) = 1</code>。允许使用的操作符为<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>。最大操作符数量为15。等级为2。</p>
<p>此题化简一下就是需要判断：</p>
<ol>
<li>如果是正数且x的第n位为0，那么就可以用n位补码表示。</li>
<li>如果是负数且x的第n位为1，那么就可以用n位补码表示。</li>
</ol>
<p>其原理为：如果要用n位的补码表示，那么所表示出来的补码第n位必须作为符号位，如果原码第n位与其符号位不相同，那么就需要n+1位补码才能表示。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 0x5</span><br><span class="line">0b0000...0101</span><br><span class="line">&#x2F;&#x2F; 其补码为</span><br><span class="line">0b0000...0101</span><br><span class="line">&#x2F;&#x2F; 如果要用3位补码表示那么表示出的补码第3位必须为0，但是0x5的原码第3为是1，所以至少需要4位0b0101才能表示0x5。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; -0x4</span><br><span class="line">0b1000...0100</span><br><span class="line">&#x2F;&#x2F; 其补码为</span><br><span class="line">0b1111...1100</span><br><span class="line">&#x2F;&#x2F; 补码的第3位是1，正好可以代表符号位，因此可以用3为补码0b100代表-4。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fitsBits - return 1 if x can be represented as an</span></span><br><span class="line"><span class="comment"> *  n-bit, two&#x27;s complement integer.</span></span><br><span class="line"><span class="comment"> *   1 &lt;= n &lt;= 32</span></span><br><span class="line"><span class="comment"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> isNeg = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">     <span class="keyword">int</span> shift = n + (~<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> (!(x &gt;&gt; shift) &amp; !isNeg) | (!(~x &gt;&gt; shift) &amp; isNeg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="divpwr2"><a href="#divpwr2" class="headerlink" title="divpwr2"></a>divpwr2</h2><p>实现计算x除以2的n次方，其中<code>0 &lt;= n &lt;= 30</code>，向0取整，例如<code>divpwr2(15,1) = 7, divpwr2(-33,4) = -2</code>。允许的操作符为<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>，最大操作符数量为15，等级为2。</p>
<p>如果是正数的话右移n位就是除以2的n次方，但是对负数并不适用，由于需要向0取整，而移位运算都是向下取整，因此就需要给负数添加一个补充值：$2^n-1$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class="line"><span class="comment"> *  Round toward zero</span></span><br><span class="line"><span class="comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> comple = (<span class="number">1</span>&lt;&lt;n) + (~<span class="number">0</span>);  <span class="comment">// 2^n - 1</span></span><br><span class="line">    <span class="keyword">return</span> (x + ((x &gt;&gt; <span class="number">31</span>) &amp; comple)) &gt;&gt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h2><p>返回x的相反数，例如<code>negate(1) = -1</code>。允许的操作符为<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>，最大操作符数量为5，等级为2。</p>
<p>前面提到过，使用计算补码的公式即可得到一个数的相反数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * negate - return -x</span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x + <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h2><p>判断一个数是否为正数，例如<code>isPositive(-1) = 0</code>。允许的操作符为<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>，最大操作符数量为8，等级为3。</p>
<p>首先需要使用<code>!x</code>判断是否为0，之后就可以判断符号位是否为1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise</span></span><br><span class="line"><span class="comment"> *   Example: isPositive(-1) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> isZero = !x;</span><br><span class="line">    <span class="keyword">return</span> !((x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>) &amp; !isZero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><p>判断一个数是否小于等于另一个数，例如<code>isLessOrEqual(4,5) = 1</code>。允许的操作符为<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>，最大操作符数量为24，等级为3。</p>
<p>根据不等式的性质可以将<code>x &lt;= y</code>转化为<code>0 &lt;= y-x</code>，就是需要判断<code>y-x</code>是不是负数，其中<code>-x</code>可以表示为<code>~x+1</code>，但是要分三种情况：</p>
<ol>
<li>x和y同号，直接做减法不会溢出。</li>
<li>x和y异号，可能会发生溢出。该情况下若x为负数，则肯定返回1，否则肯定返回0。</li>
<li>x和y相等。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0</span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> diffSign = !(x &gt;&gt; <span class="number">31</span>) ^ !(y &gt;&gt; <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">return</span> (diffSign &amp; (x &gt;&gt; <span class="number">31</span>)) | (!diffSign &amp; !((y + (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ilog2"><a href="#ilog2" class="headerlink" title="ilog2"></a>ilog2</h2><p>返回以2为底的log(x)，其中<code>x &gt; 0</code>，例如<code>ilog2(16) = 4</code>。允许的操作符为<code>! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</code>，最大操作符数量为90，等级为4。</p>
<p>此题解法来自<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/21442088/computing-the-floor-of-log-2x-using-only-bitwise-operators-in-c">stackoverflow</a></p>
<p>可以用公式表示为<br>$$log_2(x) = 16<em>a + 8</em>b + 4<em>c + 2</em>d + 1*e (a,b,c,d,e = 0 or 1)$$<br>依次求出abcde即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class="line"><span class="comment"> *   Example: ilog2(16) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 90</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, l, m;</span><br><span class="line">    x = x | (x &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    x = x | (x &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    x = x | (x &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    x = x | (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    x = x | (x &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i = 0x55555555</span></span><br><span class="line">    i = <span class="number">0x55</span> | (<span class="number">0x55</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    i = i | (i &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// j = 0x33333333</span></span><br><span class="line">    j = <span class="number">0x33</span> | (<span class="number">0x33</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    j = j | (j &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// k = 0x0f0f0f0f</span></span><br><span class="line">    k = <span class="number">0x0f</span> | (<span class="number">0x0f</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">    k = k | (k &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// l = 0x00ff00ff</span></span><br><span class="line">    l = <span class="number">0xff</span> | (<span class="number">0xff</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// m = 0x0000ffff</span></span><br><span class="line">    m = <span class="number">0xff</span> | (<span class="number">0xff</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    x = (x &amp; i) + ((x &gt;&gt; <span class="number">1</span>) &amp; i);</span><br><span class="line">    x = (x &amp; j) + ((x &gt;&gt; <span class="number">2</span>) &amp; j);</span><br><span class="line">    x = (x &amp; k) + ((x &gt;&gt; <span class="number">4</span>) &amp; k);</span><br><span class="line">    x = (x &amp; l) + ((x &gt;&gt; <span class="number">8</span>) &amp; l);</span><br><span class="line">    x = (x &amp; m) + ((x &gt;&gt; <span class="number">16</span>) &amp; m);</span><br><span class="line">    x = x + ~<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Floating-Point-Operations"><a href="#Floating-Point-Operations" class="headerlink" title="Floating-Point Operations"></a>Floating-Point Operations</h1><h2 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h2><p>返回uf的相反数，如果uf是NaN则返回自身。允许使用条件与循环语句。允许使用任何int与unsigned操作符。最大操作符数量为10，等级为2。</p>
<p>可以直接修改符号位返回相反数。另外如果uf的指数位为0xff并且小数位非0时，uf为NaN，因此就需要判断uf的绝对值是否大于0x7f800000。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> ((uf &amp; ~mask) &gt; (<span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>))</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    <span class="keyword">return</span> uf ^ mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h2><p>将一个整数转换为浮点数表示的形式。允许使用条件与循环语句，允许使用任何int和unsigned操作符。。最大操作符数量为30，等级为4。</p>
<p>浮点数的表示主要有三个部分：符号位sign，指数位exp和小数位frac。首先找到符号位后将x取绝对值(符号位归0)，通过右移找到x最高位的1的位置(找到x的2的最高次方)再加127就得到指数位exp，之后就需要计算小数位frac，由于int有31位，而浮点数小数位只有23位存放数据，因此从int转为float会丢失8位的精度，这时就需要对小数位向偶数舍入。int类型中有两个特殊值：0和0x80000000，这两个特殊值不能通过移位计算指数位与小数位因此要单独处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sign, <span class="built_in">exp</span>, frac, bitc, tailb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0x80000000</span>) <span class="keyword">return</span> <span class="number">0xCF000000</span>;</span><br><span class="line"></span><br><span class="line">    sign = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">if</span> (sign) x = -x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count bits to the right of MSB</span></span><br><span class="line">    bitc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((x &gt;&gt; bitc) != <span class="number">0</span>)</span><br><span class="line">        bitc++;</span><br><span class="line">    bitc--;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exp</span> = bitc + <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">    x = x &lt;&lt; (<span class="number">31</span> - bitc); <span class="comment">// clear all those zeros to the left of MSB</span></span><br><span class="line">    frac = (x &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x7FFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round to even (nearest)</span></span><br><span class="line">    <span class="keyword">if</span> (bitc &gt; <span class="number">23</span>) &#123;</span><br><span class="line">        tailb = x &amp; <span class="number">0xFF</span>; <span class="comment">// byte to round</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((tailb &gt; <span class="number">128</span>) || ((tailb == <span class="number">128</span>) &amp;&amp; (frac &amp; <span class="number">1</span>))) &#123;</span><br><span class="line">            frac += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (frac &gt;&gt; <span class="number">23</span>) &#123;</span><br><span class="line">                <span class="built_in">exp</span> += <span class="number">1</span>;</span><br><span class="line">                frac = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (sign &lt;&lt; <span class="number">31</span>) | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h2><p>返回浮点数uf乘2的结果，如果uf为NaN则返回自身。允许使用条件与循环语句，允许使用任何int和unsigned操作符。最大操作符数量为30，等级为4。</p>
<p>浮点数乘2其实就是将exp加1，但是需要单独处理一些特殊情况，例如NaN，正负0(0x0, 0x80000000)和非规格化的浮点数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = (<span class="number">0x1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uf &amp; ~mask) &gt;= (<span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>))</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((uf &amp; (<span class="number">0xFF</span> &lt;&lt; <span class="number">23</span>)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (uf &amp; ~(<span class="number">0x1FF</span> &lt;&lt; <span class="number">23</span>)) &lt;&lt; <span class="number">1</span> | (uf &amp; mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uf + (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/WriteUp/" rel="tag"># WriteUp</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/11/AWDL%E5%8D%8F%E8%AE%AE%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/" rel="prev" title="AWDL协议及漏洞分析">
      <i class="fa fa-chevron-left"></i> AWDL协议及漏洞分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/10/SSRF-CheatSheet/" rel="next" title="SSRF CheatSheet">
      SSRF CheatSheet <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">背景知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bit-Manipulations"><span class="nav-number">2.</span> <span class="nav-text">Bit Manipulations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bitAnd"><span class="nav-number">2.1.</span> <span class="nav-text">bitAnd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getByte"><span class="nav-number">2.2.</span> <span class="nav-text">getByte</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#logicalShift"><span class="nav-number">2.3.</span> <span class="nav-text">logicalShift</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bitCount"><span class="nav-number">2.4.</span> <span class="nav-text">bitCount</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bang"><span class="nav-number">2.5.</span> <span class="nav-text">bang</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Two%E2%80%99s-Complement-Arithmetic"><span class="nav-number">3.</span> <span class="nav-text">Two’s Complement Arithmetic</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tmin"><span class="nav-number">3.1.</span> <span class="nav-text">tmin</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fitsBits"><span class="nav-number">3.2.</span> <span class="nav-text">fitsBits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#divpwr2"><span class="nav-number">3.3.</span> <span class="nav-text">divpwr2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#negate"><span class="nav-number">3.4.</span> <span class="nav-text">negate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isPositive"><span class="nav-number">3.5.</span> <span class="nav-text">isPositive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isLessOrEqual"><span class="nav-number">3.6.</span> <span class="nav-text">isLessOrEqual</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ilog2"><span class="nav-number">3.7.</span> <span class="nav-text">ilog2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Floating-Point-Operations"><span class="nav-number">4.</span> <span class="nav-text">Floating-Point Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#float-neg"><span class="nav-number">4.1.</span> <span class="nav-text">float_neg</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#float-i2f"><span class="nav-number">4.2.</span> <span class="nav-text">float_i2f</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#float-twice"><span class="nav-number">4.3.</span> <span class="nav-text">float_twice</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Srpopty</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Srpopty" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Srpopty" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:srpopty@outlook.com" title="E-Mail → mailto:srpopty@outlook.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Srpopty</span>
</div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='255,255,255' opacity='1' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'fb9b672afa74e328fbe8',
      clientSecret: '7b3efe103d7e694008b943a67e5273ad36ee14a0',
      repo        : 'srpopty.github.io',
      owner       : 'Srpopty',
      admin       : ['Srpopty'],
      id          : 'c471219c22262ab7d86c1e3a0b55830a',
        language: 'en',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
